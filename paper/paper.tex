% \documentclass[sigplan, screen]{acmart}
% \documentclass[sigplan, screen, anonymous, review, authordraft]{acmart}
% \documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\documentclass[sigplan,10pt]{acmart}

\usepackage{agda-unicode}

\bibliographystyle{ACM-Reference-Format}

\title{Abstractions for Multi-Sorted Substitutions}

\author{Hannes Saffrich}
\orcid{0000-0002-1825-0097}                 %% \orcid is optional
\affiliation{
  % \department{Department1}                %% \department is recommended
  \institution{University of Freiburg}      %% \institution is required
  \country{Germany}                         %% \country is recommended
}
\email{saffrich@informatik.uni-freiburg.de} %% \email is recommended

% \author{Peter Thiemann}
% \orcid{0000-0002-9000-1239}                 %% \orcid is optional
% \affiliation{
%   % \department{Department2a}               %% \department is recommended
%   \institution{University of Freiburg}      %% \institution is required
%   \country{Germany}                         %% \country is recommended
% }
% \email{thiemann@informatik.uni-freiburg.de} %% \email is recommended

\usepackage{tcolorbox}

\newenvironment{LibCode*}{%
  \begin{tcolorbox}[%
    colframe=white,%
    boxrule=0.0pt,%
    top=2.5pt,%
    left=2.5pt,%
    bottom=2.5pt,%
    right=2.5pt,%
    boxsep=0pt%
  ]\vspace{-0.2\baselineskip}%
}{%
  \vspace{-1\baselineskip}%
  \end{tcolorbox}%
}

\newenvironment{ExampleCode*}{%
  \begin{tcolorbox}[%
    colframe=white,%
    colback=yellow!5,%
    boxrule=0.0pt,%
    top=2.5pt,%
    left=2.5pt,%
    bottom=2.5pt,%
    right=2.5pt,%
    boxsep=0pt%
  ]\vspace{-0.2\baselineskip}%
}{%
  \vspace{-1\baselineskip}%
  \end{tcolorbox}%
}

\newcommand*\LibCode[1]{\begin{LibCode*}{#1}\end{LibCode*}}
\newcommand*\AppCode[1]{{#1}}
\newcommand*\ExampleCode[1]{\begin{ExampleCode*}{#1}\end{ExampleCode*}}

\begin{document}
  \begin{abstract}
    Variable binding and substitution are a long-standing nuisance for mechanized
    metatheory of programming languages. A common approach is to represent
    variables as DeBruijn Indices, where substitution is defined in terms of
    variable renaming. If a language has $n$ different kinds of variables, and
    $m$ different kinds of terms, we potentially need to define both
    renaming and substitution for all $m\cdot n$ combinations and prove the
    theory of those operations both in isolation and with respect to each other.

    % McBride introduced kits to define both substitution and renaming by a
    % single term traversal for intrinsically typed terms.\cite{mcbride2005kits}

    We propose a technique to derive the implementation and metatheory of
    renaming and substitution for all $m\cdot n$ combinations of variables and terms
    from a single term traversal and three simple lemmas for extrinsically typed
    but intrinsically scoped terms.
    We demonstrate this technique by formalizing type soundness of System F with
    very parallel substitutions, which replace both type and term variables at
    once, enabling a single substitution-preserves-typing lemma.
    We provide a well-documented implementation of the technique as an Agda
    library.

    As the technique is based on extrinsic typing, the metatheory of renaming
    and substitution is decoupled from type preservation.
    This has the downside, that type preservation of renaming and substitution
    are not for free, but also the upside, that the library can be directly
    instantiated for object languages with non-standard typing relations like
    dependent types, type state, or resource environments.
  \end{abstract}

  \maketitle

  % The following line will be replaced by make with an \input{} for each
  % .lagda.tex file:

  % SED MARKER

  \AgdaNoSpaceAroundCode{}

  \section{Introduction}
  Formalizing metatheory of programming languages in a proof assistant 
  requires to deal with variables, binders and substitution.

  In most languages those constructs behave uniformly,
  i.e. substitution is only concerned with variables and binders and
  behaves homomorphic on all other syntax constructors.

  Intrinsic typing 


  \begin{enumerate}
  \item DeBruijn
  \item Intrinsic vs Extrinsic
  \item Reduction under binder
  \end{enumerate}

  \subsection{Structure}
  The rest of this paper will introduce our framework using System F
  as a running example for a type soundness proof.

  Code of the framework is displayed in gray boxes.
  Code of examples is written in yellow boxes.
  Code of the System F formalization is written without boxes. This is
  the only code a user of our framework has to write.

  In the paper we state all definitions and lemmas, but omit some proofs
  in the interest of space. However the omitted proofs exclusively
  depend on lemmas and definitions stated in this paper. The full code
  from the paper can be found at TODO.

  In the paper we only show the part of the framework necessary for
  the System F soundness proof. The actual implementation is more
  general and complete and can be found at TODO.

  \subsection{Contributions}
  \begin{enumerate}
  \item
    a multi-sorted approach to extrinsic typing;
  \item
    a multi-sorted extension of McBride's kits to unify renamings and substitutions and their metatheory;
  \item
    an abstraction for composition and it's metatheory, unifying the four combinations of renamings and substitutions;
  \item
    an abstraction for typing relations, unifying type preservation of renaming and substitution into a single lemma;
  \item
    an Agda-implementation featuring derived term-kits, representation
    independence for substitutions and typing contexts, heterogeneous
    equality, independence of functional extensionality, case studies
    on System F, dependent lambda calculus, pattern matching, linear
    types.
  \end{enumerate}

  \newpage

  \section{Syntax}
  \subsection{Single-Sorted Syntax}
  The following shows a typical intrinsically-scoped syntax of System F:
  \ExampleCode\FUnsortedSyntax

  \texttt{Type}s are indexed by the number of free type variables \texttt{n}.
  \texttt{Expr}essions are additionally indexed by the number of free expression variables \texttt{m}.
  Variables \texttt{`\_} are represented as DeBruijn-indices, where \texttt{Fin n} is the type of \texttt{n} elements.

  We identify two drawbacks with this style of syntax:
  \begin{enumerate}
  \item the syntactic categories (\texttt{Kind}, \texttt{Type}, and \texttt{Expr})
    have different types, which makes it difficult to treat them uniformly; and
  \item the different sorts of variables are modeled separately, which requires to define not just
    type-in-type and expression-in-expression substitution, but also type-in-expression substitution.
    Consequently, interaction lemmas between those substitutions are required.
    In general, this leads to a combinatory explosion of
    substitutions, e.g.\ adding kind variables would lead to a total of 6
    different substitutions.
  \end{enumerate}

  \subsection{Multi-Sorted Syntax}
  To avoid these drawbacks, we define the whole syntax as a single sort-indexed type of terms.

  A sort describes to which syntactic category a term belongs and is
  itself indexed by a sort type which describes whether the syntax
  permits variables of this sort:
  \LibCode\KSortTy
  \AppCode\FSort
  
  The term type \texttt{S~‚ä¢~s} is then indexed by its sort \texttt{s} and the sorts of its free variables \texttt{S}.
  For example, \texttt{[ùï•, ùï•] ‚ä¢ ùïñ} is the type of expressions (\texttt{ùïñ}) with two free type-variables (\texttt{ùï•}).
  \newpage
  \AppCode\FSyntax
  The notation \texttt{\_‚ä¢\_} is often used for well-typed terms in
  intrinsically-typed languages. This is no accident: in effect, we
  defined an intrinsically-typed language with the twist that the
  typing relation assures exactly that the syntactic categories are followed.
  Sorts \texttt{s} correspond to types, and lists of sorts \texttt{S}
  correspond to type environments.

  As it is typical in intrinsic typing, variables are represented as
  typed (in our case sorted) DeBruijn indices \texttt{S~‚àã~s}, i.e.\
  values of the usual proof-relevant list-membership relation:
  \LibCode\KVariables

  Contrary to the usual intrinsic typing, we limit the environment
  \texttt{S} to sorts with index \texttt{Var}.
  This ensures that it is impossible to construct kind variables, as
  it is not possible to extend \texttt{S} with the sort of kinds
  \texttt{ùïú}.

  \subsection{A Structure for Multi-Sorted Syntax}
  The rest of our framework builds on top of a multi-sorted
  syntax for which we define the following structure:
  \LibCode\KTerms
  The first three fields record the definitions of sorts, terms, and variable introduction.
  The last field records that variable introduction
  \texttt{`\_} is injective, which is trivially true for
  constructors. The instantiation for our System F syntax is
  straightforward:
  \AppCode\FTerms

  \section{Renamings \& Substitutions}
  \subsection{Multi-Sorted Renamings \& Substitutions}
  Working with a sort-indexed syntax allows us to define renamings and substitutions
  which replace all variables of all sorts simultaneously:

  \ExampleCode\FExampleSubRen

  A renaming \texttt{S‚ÇÅ ‚Üí·µ£ S‚ÇÇ} maps variables from \texttt{S‚ÇÅ} to
  variables from \texttt{S‚ÇÇ}.
  A substitution \texttt{S‚ÇÅ ‚Üí‚Çõ S‚ÇÇ} maps variables from \texttt{S‚ÇÅ} to
  terms containing variables from \texttt{S‚ÇÇ}.

  For example, the substitution, which replaces the term variable 0 with the
  identity function and the type variable 1 with the bottom type, is defined
  as followed:
  \ExampleCode\FExampleSub

  This representation has the benefit that there is no combinatory
  explosion of substitutions and renamings, e.g.\ no extra lemmas have to be
  proved between an expression-in-expression and a type-in-expression
  substitution, because both are simply substitutions.

  \subsection{Unifying Renamings \& Substitutions}
  A well-known problem with DeBruijn-indices is that the operation of
  applying a substitution \texttt{œÉ} to a term \texttt{t} cannot be
  defined directly by structural recursion on \texttt{t}.
  If \texttt{t} is a term like \texttt{Œªx e},
  where the subterm \texttt{e} is under a binder, then the variables
  in \texttt{e} are shifted, i.e.  the variable \texttt{zero} refers
  to the variable from the binder, whereas a variable \texttt{suc x}
  refers to the variable \texttt{x} from outside of the binder.
  As the terms contained in \texttt{œÉ} may themselves contain free variables,
  they need to be shifted, too, before they can be substituted
  for variables in \texttt{e}. 
  Shifting the variables in a term is itself a substitution, which maps
  each variable \texttt{x} to the term \texttt{` (suc x)}.
  However, applying this shifting substitution to the terms in
  \texttt{œÉ} is not structurally recursive, as the terms in \texttt{œÉ}
  are not subterms of \texttt{Œªx e}.


  \subsection{Unifying Renamings \& Substitutions}
  A well-known problem with DeBruijn-indices is that full substitution
  cannot be defined directly by structural recursion on the term.
  The usual workaround is to define renamings first and use them
  to weaken the terms in substitutions when going under binders.

  While this keeps lemmas simple (requiring only structural induction),
  it duplicates the amount of work as all operations and lemmas have
  to be defined and proved for both renamings and substitutions.

  To avoid this duplication,
  McBride\cite{DBLP:journals/jar/BentonHKM12, unpublished:mcbride2005kits}
  introduced an abstraction called \emph{Kits}, which allows to talk about
  both renamings and substitutions simultaneously.

  The core observation leading to this abstraction is that renamings
  and substitutions only differ in their return type:
  \ExampleCode\FExampleSubRen

  In both cases \texttt{\_‚àã\_} and \texttt{\_‚ä¢\_} are instanciated to the type
  \LibCode\KScoped
  which allows us to create a structure to axiomatize the common
  theory behind both of them:
  \LibCode\KKit



  \subsection{Library}
  \LibCode\KAp
  \LibCode\KExt
  \LibCode\KLift
  \LibCode\KId
  \LibCode\KSingle
  \LibCode\KWeaken
  \LibCode\KEq
  \LibCode\KFunExt
  \LibCode\KIdLift
  % \LibCode\KIdLiftProof
  \LibCode\KKitNotation
  \LibCode\KTraversal
  \LibCode\KKitInstances
  \LibCode\KKitOpen
  \subsection{System F}
  \AppCode\FTraversalOp
  \AppCode\FTraversalId
  \AppCode\FTraversalIdProofInteresting
  % \LibCode\FTraversalIdProofRest
  \AppCode\FTraversal

  \section{Map Composition}
  \subsection{Library}
  \LibCode\KWkKit
  \LibCode\KWkKitInstances
  \LibCode\KComposeKit
  \LibCode\KComposition
  \LibCode\KComposeKitAp
  % \LibCode\KComposeKitApProof
  \LibCode\KDistLiftCompose
  % \LibCode\KDistLiftComposeProof
  \LibCode\KComposeKitNotation
  \LibCode\KComposeTraversal
  \LibCode\KCommLiftWeaken
  % \LibCode\KCommLiftWeakenProof
  \LibCode\KCommLiftWeakenTraverse
  % \LibCode\KCommLiftWeakenTraverseProof
  \LibCode\KComposeKitInstances
  \LibCode\KComposeKitInstancesConcrete
  \LibCode\KWeakenCancelsSingle
  % \LibCode\KWeakenCancelsSingleProof
  \LibCode\KWeakenCancelsSingleTraverse
  % \LibCode\KWeakenCancelsSingleTraverseProof
  \LibCode\KDistLiftSingle
  % \LibCode\KDistLiftSingleProof
  \LibCode\KDistLiftSingleTraverse
  % \LibCode\KDistLiftSingleTraverseProof
  \subsection{System F}
  \AppCode\FAssoc
  \AppCode\FAssocProofInteresting
  % \AppCode\FAssocProofRest
  \AppCode\FComposeTraversal

  \section{Types \& Contexts}
  \subsection{Library}
  \LibCode\KTypeSorts
  \LibCode\KTypes
  \LibCode\KContextHelper
  \LibCode\KContexts
  \LibCode\KContextLookup
  \subsection{System F}
  \AppCode\FTypes

  \section{Typing}
  % TODO move to typing section
  The only drawback we found, is that types can now also be indexed
  with free expression variables, even though types can never contain
  free variables as assured by the variable constructor. However, this
  only causes minor issues.

  \subsection{Library}
  \LibCode\KVariableTyping
  \LibCode\KTyping
  \LibCode\KTypingKit
  \LibCode\KMapTyping
  \LibCode\KLiftTyping
  % \LibCode\KLiftTypingProof
  \LibCode\KSingleTyping
  % \LibCode\KSingleTypingProof
  \LibCode\KTypingNotation
  \LibCode\KTypingTraversal
  \LibCode\KTypingInstances
  % \LibCode\KTypingTraversalNotation
  \subsection{System F}
  \AppCode\FTyping
  \AppCode\FTypingInst
  \AppCode\FPreserve
  \AppCode\FTypingTraversal

  \section{Semantics}
  % \AppCode\FValues
  \AppCode\FReduction

  \section{Subject Reduction}
  \AppCode\FSubjectReduction
  \AppCode\FSubjectReductionProofInteresting
  % \FSubjectReductionProofRest

  \section{Related Work}
  Autosubst \cite{DBLP:conf/cpp/StarkSK19, DBLP:conf/itp/SchaferTS15}.
  Kits \cite{DBLP:journals/jar/BentonHKM12, unpublished:mcbride2005kits}.
  Kits linear \cite{DBLP:journals/corr/abs-2005-02247}.
  Universe \cite{DBLP:journals/pacmpl/AllaisA0MM18}.

  % \bibliographystyle{ACM-Reference-Format}
  \bibliography{paper}

  \clearpage
  \appendix
\end{document}