% PAGE LIMIT: 16

% \documentclass[sigplan, screen]{acmart}
% \documentclass[sigplan, screen, anonymous, review, authordraft]{acmart}
% \documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
% \documentclass[sigplan,10pt, anonymous]{acmart}
\documentclass[a4paper, UKenglish, cleveref, autoref, thm-restate]{lipics-v2021}

\usepackage{agda-unicode}
\usepackage{agda-generated}
\AgdaNoSpaceAroundCode{}

% \bibliographystyle{ACM-Reference-Format}
\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Abstractions for Multi-Sorted Substitutions}
\author{Hannes Saffrich}{University of Freiburg, Germany}{saffrich@informatik.uni-freiburg.de}{https://orcid.org/0009-0004-7014-754X}{}
\authorrunning{H. Saffrich}
\Copyright{Hannes Saffrich}
\keywords{Agda, Metatheory, Framework}
% \relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional
% \acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% \author{Hannes Saffrich}
% \orcid{0000-0002-1825-0097}                 %% \orcid is optional
% \affiliation{
%   % \department{Department1}                %% \department is recommended
%   \institution{University of Freiburg}      %% \institution is required
%   \country{Germany}                         %% \country is recommended
% }
% \email{saffrich@informatik.uni-freiburg.de} %% \email is recommended

% \author{Peter Thiemann}
% \orcid{0000-0002-9000-1239}                 %% \orcid is optional
% \affiliation{
%   % \department{Department2a}               %% \department is recommended
%   \institution{University of Freiburg}      %% \institution is required
%   \country{Germany}                         %% \country is recommended
% }
% \email{thiemann@informatik.uni-freiburg.de} %% \email is recommended

\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011039.10011040</concept_id>
       <concept_desc>Software and its engineering~Syntax</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10002990</concept_id>
       <concept_desc>Theory of computation~Logic and verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Software and its engineering~Syntax}
\ccsdesc[500]{Theory of computation~Logic and verification}

\usepackage{tcolorbox}

\newenvironment{LibCode*}{%
  \begin{tcolorbox}[%
    colframe=white,%
    boxrule=0.0pt,%
    top=2.5pt,%
    left=2.5pt,%
    bottom=2.5pt,%
    right=2.5pt,%
    before skip=5pt,%
    after skip=5pt,%
    boxsep=0pt%
  ]
}{%
  \end{tcolorbox}%
}

\newenvironment{ExampleCode*}{%
  \begin{tcolorbox}[%
    colframe=white,%
    colback=yellow!5,%
    boxrule=0.0pt,%
    top=2.5pt,%
    left=2.5pt,%
    bottom=2.5pt,%
    right=2.5pt,%
    before skip=5pt,%
    after skip=5pt,%
    boxsep=0pt%
  ]\vspace{-0.2\baselineskip}%
}{%
  \vspace{-1\baselineskip}%
  \end{tcolorbox}%
}

\newcommand*\LibCode[1]{\begin{LibCode*}{#1}\end{LibCode*}}
\newcommand*\AppCode[1]{{#1}}
\newcommand*\ExampleCode[1]{\begin{ExampleCode*}{#1}\end{ExampleCode*}}

% \setlength\fboxsep{0pt}
% \usepackage{realboxes}
% \definecolor{mygray}{rgb}{0.95,0.95,0.95}
% \newcommand*\ACode[1]{\Colorbox{mygray}{\AgdaFontStyle{#1}}}

% \newcommand*\ACode[1]{\AgdaFontStyle{#1}}

% \newcommand*\ACode[1]{\texttt{#1}}

\definecolor{mygray}{rgb}{0.4,0.4,0.4}
\newcommand*\ACode[1]{\AgdaFontStyle{\textcolor{mygray}{#1}}}

\newcommand*\AField[1]{\AgdaField{#1}}
\newcommand*\ACon[1]{\AgdaInductiveConstructor{#1}}
\newcommand*\AKw[1]{\AgdaKeyword{#1}}
\newcommand*\ADef[1]{\AgdaFunction{#1}}

\begin{document}

  \maketitle

  \begin{abstract}
    Formalizing a typed programming language in a proof assistant
    requires to choose representations for variables and typing.
    Variables are often represented as de Bruijn indices, where
    substitution is usually defined in terms of renamings to allow for
    proofs by structural induction.
    Typing can be represented extrinsically by defining untyped terms and a typing
    relation, or intrinsically by combining syntax and typing into a single
    definition of well-typed terms.
    For extrinsic typing, there is again a choice between extrinsic
    scoping, where terms and the notion of free variables are defined
    separately, and intrinsic scoping, where terms are indexed by their
    free variables.

    This paper describes an Agda framework for formalizing programming
    languages with extrinsic typing, intrinsic scoping, and de Bruijn
    Indices for variables.
    The framework supports object languages with arbitrary many
    variable sorts and dependencies, making it suitable for
    polymorphic languages and dependent types.
    Given an Agda definition of syntax and typing, the framework derives
    substitution operations and lemmas for untyped terms, and provides an
    abstraction to prove type preservation of these operations with
    just a single lemma.
    The key insights behind the framework are the use of multi-sorted syntax
    definitions, which enable parallel substitutions that replace
    all variables of all sorts simultaneously, and
    abstractions that unify the definitions, compositions, typings,
    and type preservation lemmas of multi-sorted renamings and substitutions.
    Case studies have been conducted to prove subject reduction for
    System F with subtyping, dependently typed lambda calculus, and lambda
    calculus with pattern matching.
  \end{abstract}

  \section{Introduction}
  \label{sec:introduction}

  Formalizing programming languages in proof assistants quickly gets
  repetitive. Almost every programming language supports variables
  with static binding, and hence requires numerous definitions and
  lemmas related to variable substitution.

  Additionally, repetition can also occur within a single formalization.
  This can be seen with polymorphic languages, where multiple sorts
  of variables are present.
  Consider for example System F, which supports both expression- and
  type-variables.
  With a naive approach, the whole substitution machinery needs to be
  duplicated three times! We need to substitute expression-variables in
  expressions, type-variables in types, but also type-variables in
  expressions.
  Even worse, having two substitutions acting on expressions requires
  to also prove lemmas about their interactions.
  If we would additionally introduce kind-variables, we would end up
  with a total of six duplications of the substition machinery and
  corresponding interaction lemmas!
  
  Further repetition can occur due to the choice of variable
  representation. For example, for de Bruijn indices, substitution is
  usually defined in terms of renamings to allow for structural
  induction.
  With a naive approach, this would again double the amount of
  substitution machinery, as all definitions and lemmas need to be
  written first for renamings and then again for substitutions.

  Similarly, for a typed language formalized via extrinsic typing we
  need type preservation lemmas for each substitution and renaming
  operation, which again doubles the number of definitions.

  % In summary, to have enough substitution machinery to prove subject
  % reduction for a language with expression-, type-, and
  % kind-variables one can end up with a total of 24
  % repetitions for each definition related to substitution, not counting
  % the interaction lemmas between different substitutions that are
  % acting on the same syntactic categories!
  If one is not careful, a formalization of a language with type and
  kind polymorphism can easily end up with 24 slightly changed copies of
  the whole substitution machinery!
  Clearly, this situation is in need of automation.

  Our framework approaches this problem by using a combination of
  abstractions and reflection in the context of extrinsically typed,
  intrinsically scoped syntax with de Bruijn indices.
  The user can write a language specification using regular Agda
  definitions (no generic encodings) and our framework derives
  definitions and lemmas for untyped substitution, and provides an
  abstraction to prove type preservation for all substitution operations
  with only a single lemma. For System F, our framework allows to prove
  subject reduction with only a single handwritten lemma for type
  preservation.

  Compared to many other approaches, we do not derive substitutions
  for each of the variable sorts and syntactic categories, but instead
  use a novel approach for defining syntax, which directly supports
  substitutions that replace all variable sorts in parallel and can be
  applied to all syntactic categories.
  By further unifying renamings and substitutions, we gain the ability
  to talk abstractly about any kind of renaming or substitution that
  can occur in the formalization.
  This generality is key to then define abstractions for typing and
  type preservation on the same level of generality, allowing to prove
  type preservation for renamings and substitutions of all variable
  sorts and syntactic categories in a single lemma for many typing
  relations, including those of our case studies.


  % By using extrinsic typing, we clearly separate the definitions and
  % lemmas of untyped substitutions from typing and type preservation.
  % This is useful, because the former can be derived for virtually any
  % object language, while the latter cannot, as typing relations can
  % be arbitrarily complex.

  % This does not only separate specification from proofs, making it
  % easier for a human to verify if a specification is correct without
  % understanding the proofs, but also separates things which can be
  % derived for virtually any object language, from things which cannot.

  % This allows untyped substitution to be derived for virtually all
  % object languages, while still allowing for general abstractions
  % for type preservation to be built on top, which cannot be proved
  % automatically in general, as typing relations can become arbitrarily
  % complex.
  
  

  % The class of supported typing relations is currently limited to 
  % a subclass of the classical tertiary relations between typing
  % context, term, and type, but strong enough work for our three case studies
  % of System F with subtyping, lambda calculus with dependent function
  % types, and pattern matching.

  % Choosing an extrinsic typing approach might seem counter intuitive,
  % as separating 

  % In our framework we address those repetitions as followed:
  % \begin{itemize}
  % \item
  %   Instead of requiring a separate substitution for each sort of variable,
  %   we define a multi-sorted substitution which replaces all variables
  %   of all sorts simultaneously and can be applied to terms of all syntactic categories.
  %   This not only unifies many different definitions, removing redundancy on the way,
  %   but also eliminates the need for interaction lemmas.
  % \item
  %   We use de Bruijn indices, but unify renamings and typings using the Kit abstraction.
  %   We further developed a Kit-like abstraction to also unify
  %   compositions of renamings and substitutions.
  % \end{itemize}
  
  

  % A close examination of the formalizations reveals that variable
  % substitution behaves uniformly across languages, in the sense that
  % the behavior of substitution is completely determined by the positions
  % of variable bindings and variable uses.


  % Formalizing a typed programming language in a proof assistant
  % requires to choose between an extrinsic and intrinsic representation
  % of typing.

  % With \emph{intrinsic typing}, the definitions of syntax and typing
  % are merged into a single definition of well-typed terms.
  % Consequently, the definition of an operation on terms also acts
  % as a proof of type preservation for that operation, as it has to
  % map well-typed terms to well-typed terms.
  % For example, the definition of substitution
  % also acts as a proof that substitution preserves typing, and the
  % definition of a small-step semantics also acts as a proof for subject
  % reduction.
  % This often has the benefit of more concise code, as shared structure
  % between definitions and preservation lemmas does not need to be
  % repeated.

  % With \emph{extrinsic typing}, the definitions of syntax and typing
  % are kept separately: the syntax is defined first, and then typing is
  % defined as a relation. Consequently, operations on terms and
  % their type preservation lemmas are also separate entities.
  % This has the benefit that specification and proofs are kept strictly separate,
  % allowing a human to judge whether a specification is correct without also
  % having to understand the proofs.
  % % To understand the specification of intrinsic typing one has to
  % % additionally understand the proofs, which can introduce significant
  % % cognitive overhead.

  % For our substition framework, we choose to work with extrinsic
  % typing for a different reason.

  % % For substitution, this separation brings an opportunity for automation:
  % % free from the arbitrary complexity of typing relations,
  % % the definitions and lemmas of substitution for untyped terms
  % % behaves uniformly across object languages, and can be derived
  % % completely.

  % % While extrinsic typing cannot eliminate the shared structure between
  % % definitions and preservation lemmas, it can automated by reflection
  % % or generic programming techniques, leaving only the preservation lemmas
  % % to be proven by the programmer. While typing can be arbitrary complex,
  % % the definition and metatheory of untyped substitution behaves the same
  % % across languages.

  % % However, when working with library support, this is less of a benefit.
  % % Most operations, like substitution, have a generic definition and
  % % metatheory across languages, which can be derived automatically via
  % % reflection or generic programming techniques.
  % % Only by adding a typing-relation 


  % % However, intrinsic typing also has three major drawbacks:
  % % \begin{enumerate}
  % % \item
  % %   It is more difficult to judge whether a specification is correct,
  % %   because there is no clear separation between specification and proofs.
  % %   To understand the specification one has to additionally
  % %   understand the proofs, which can introduce significant cognitive overhead.
  % %   % For example specifying a small step semantics is directly intertwined
  % %   % with the proof of subject reduction.
  % % \item
  % %   It is less uniform for object languages with multiple variable
  % %   sorts, e.g. type- and expression-variables. In such a scenario,
  % %   types are usually indexed by kinds and expressions by kinds and types.
  % %   This requires not only a type-in-type and expression-in-expression
  % %   substitution, but also a type-in-expression substitution, which causes
  % %   interactions between different types of substitutions introducing
  % %   additional complexity.
  % %   The duplication increases even more if one additionally introduces
  % %   kind-variables. Then a total of 6 different substitutions and
  % %   their interactions is required.
  % %   Unifying these substitutions to reduce repetition is difficult
  % %   with intrinsic typing due to the interdependence of definitions.
  % % \item
  % %   It is less suitable for automation, because type preservation is baked
  % %   into the syntax definition and type preservation can become arbitrary complex
  % %   depending on the typing relation. This can prevent substitition
  % %   definition and lemmas from being derived, where otherwise it would be possible.
  % % \end{enumerate}
  % % With extrinsic typing the major drawback is the duplication between
  % % definitions and type preservation lemmas, which we found more
  % % suitable to be eliminated by automation.

  % % To combat those drawbacks, we went in the direction of intrinsically
  % % scoped syntax in our search for a general, clean, and automated framework
  % % for metatheory.

  \subsection{Structure}
  \label{sec:introduction:structure}

  The rest of this paper introduces our framework using System F
  as a running example for a substitution-preserves-typing proof.

  Code of the framework is displayed in gray boxes.
  Code of examples is displayed in yellow boxes.
  Code of the System F formalization is displayed without boxes. The
  latter is the only code a user of our framework has to write.

  In this paper, we present a simplified version of the actual
  framework, focusing on the core concepts. We present all necessary
  definitions and lemmas, but omit some proofs for the sake of
  space. The omitted proofs can be found in our supplementary material,
  which includes the simplified framework (368 lines of code) and the
  System F formalization (221 lines of code).
  The full framework including the case studies is available on Github:
  \textcolor{blue}{\url{https://github.com/m0rphism/kitty}}
  % The full framework is available online.\footnote{See supplementary material. In the final version, this text will be replaced by a link to github.}

  The rest of this paper is structured as follows:
  Section~\ref{sec:syntax} introduces the multi-sorted syntax and compares it to the
  more common unsorted syntax.
  Section~\ref{sec:maps} introduces multi-sorted substitutions and renamings, and
  an abstraction to unify them.
  Section~\ref{sec:composition} introduces composition of multi-sorted
  substitions and renamings, and an abstraction to unify all four
  compositions.
  Section~\ref{sec:types} shows how to define types,
  type contexts, and typing relations,
  and presents an abstraction for unifying type preservation lemmas for renamings and substitutions.
  % Section~\ref{sec:subjectreduction} introduces a small-step
  % operational semantics for System F and proves subject reduction.
  Section~\ref{sec:reflection} describes the class of object languages covered by
  our reflection algorithm.
  Section~\ref{sec:casestudies} discusses our case studies.
  Section~\ref{sec:related} discusses related work.
  Section~\ref{sec:conclusion} concludes.

  \subsection{Contributions}
  \label{sec:introduction:contributions}
  \begin{enumerate}
  \item
    a novel approach for formalizing intrinsically-scoped syntax with
    multiple variable sorts as a special kind of intrinsically-typed
    syntax, we call \emph{multi-sorted syntax};
  % \item
  %   an adaptation of McBride's
  %   kit-abstraction\cite{DBLP:journals/jar/BentonHKM12, unpublished:mcbride2005kits}
  %   for unifying renamings and substitutions to multi-sorted syntax;
  \item
    a novel abstraction for composition and its metatheory, unifying
    the four compositions between renamings and substitutions;
  \item
    a novel abstraction for typing, unifying type
    preservation of renaming and substitution;
  \item
    a formalized specification of a large class of object languages
    for which untyped substitution and lemmas can be derived generically.
  \item
    an implementation as an Agda framework featuring
    a reflection algorithm, representation independence for
    substitutions and type contexts, heterogeneous equality between
    renamings and substitutions, and absence of postulated axioms.
  \item
    three case studies in using our approach to prove subject reduction
    for System~F with subtyping, a dependently-typed lambda calculus, and
    pattern matching.
  \end{enumerate}

  \section{Syntax}
  \label{sec:syntax}
  \subsection{Unsorted Syntax}
  \label{sec:syntax:single}
  The following shows a typical intrinsically-scoped syntax of System F:
  \ExampleCode\FUnsortedSyntax

  \ACode{\ACon{Type}}s are indexed by the number of free type
  variables \ACode{n}.
  \ACode{\ACon{Expr}}essions are additionally indexed by the number of
  free expression variables \ACode{m}.
  Variables \ACode{\ACon{`\_}} are represented as de Bruijn indices, where
  \ACode{\ACon{Fin} n} is the type of \ACode{n} elements.

  We identify two drawbacks with this style of syntax:
  \begin{enumerate}
  \item
    the syntactic categories (\ACode{\ACon{Kind}},
    \ACode{\ACon{Type}}, and \ACode{\ACon{Expr}})
    have different types, which makes it difficult to treat them uniformly; and
  \item the different sorts of variables are modeled separately, which requires to define not just
    type-in-type and expression-in-expression substitution, but also type-in-expression substitution.
    Consequently, interaction lemmas between the substitutions are required.
    % In general, this leads to a combinatory explosion of
    % substitutions, e.g.\ adding kind variables would lead to a total of 6
    % different substitutions and corresponding interaction lemmas.
  \end{enumerate}
  To avoid these drawbacks, we instead use a multi-sorted syntax.

  \subsection{Multi-Sorted Syntax}
  \label{sec:syntax:multi}
  A multi-sorted syntax is defined by a single type of sort-indexed terms.

  A sort describes to which syntactic category a term belongs and is
  itself indexed by a sort type, which describes whether the syntax
  permits variables of this sort:
  \LibCode\KSortTy
  \AppCode\FSort
  
  The term type \ACode{S \ACon{⊢} s} is indexed by its sort
  \ACode{s} and the sorts of its free variables \ACode{S}.
  For example, \ACode{\ACon{[𝕥, 𝕥] ⊢ 𝕖}} is the type of expressions
  (\ACode{\ACon{𝕖}}) with two free type-variables (\ACode{\ACon{𝕥}}).
  \AppCode\FSyntax
  The notation \ACode{\ACon{\_⊢\_}} is often used for terms in
  intrinsically-typed languages. This is no accident: in effect, we
  defined an intrinsically-typed language with the twist that the
  typing relation assures exactly that the syntactic categories are followed.
  Sorts \ACode{s} correspond to types, and lists of sorts \ACode{S}
  correspond to type environments.

  As it is typical in intrinsic typing, variables are represented as
  typed (in our case sorted) de Bruijn indices \ACode{S \ACon{∋} s}, i.e.\
  values of the usual proof-relevant list-membership relation:
  \LibCode\KVariables

  Note that there is no straightforward way to construct a
  multi-sorted syntax with intrinsic typing: in a direct translation,
  the type of terms \ACode{\ACon{\_⊢\_}} would be indexed by itself, which
  most proof assistants forbid to avoid breaking logical consistency.
  % We conjecture that an encoding might be possible, as it has been
  % done for intrinsically typed languages with dependent
  % types\cite{DBLP:conf/popl/AltenkirchK16}, but those constructions come
  % with additional complexity and are less suitable to automation.

  % Contrary to the usual intrinsic typing, we limit the environment
  % \ACode{S} to sorts with index \ACode{\ACon{Var}}.
  % This ensures that it is impossible to construct kind variables, as
  % it is not possible to extend \ACode{S} with the sort of kinds
  % \ACode{\ACon{𝕜}}.

  \subsection{A Structure for Multi-Sorted Syntax}
  \label{sec:syntax:structure}
  % The regularity of the multi-sorted syntax makes it easy to define a
  % structure for syntaxes of arbitrary object-languages, i.e.\ syntaxes
  % with arbitrary amounts of syntactic categories and variables:
  The regularity of the multi-sorted syntax makes it easy to define a
  structure for arbitrary syntaxes, i.e.\ syntaxes with arbitrarily
  many syntactic categories and variable types:
  \LibCode\KSyntax
  \noindent The first three fields record the definitions of sorts, terms, and variable introduction.
  The last field records that variable introduction
  \ACode{\AField{`\_}} is injective, which is trivially true for
  constructors. The instantiation for our System F syntax is
  straightforward:
  \AppCode\FSyntaxInst

  \section{Renamings \& Substitutions}
  \label{sec:maps}
  \subsection{Multi-Sorted Renamings \& Substitutions}
  \label{sec:maps:example}
  Working with a sort-indexed syntax allows us to define renamings and substitutions
  that replace all variables of all sorts simultaneously:

  \ExampleCode\FExampleSubRen

  \noindent A renaming \ACode{S₁ \ADef{→ᵣ} S₂} maps variables from \ACode{S₁} to
  variables from \ACode{S₂}.
  A substitution \ACode{S₁ \ADef{→ₛ} S₂} maps variables from \ACode{S₁} to
  terms with free variables from \ACode{S₂}.

  % For example, the substitution, which replaces the term variable 0 with the
  % identity function and the type variable 1 with the bottom type, is defined
  % as followed:
  % \ExampleCode\FExampleSub

  This representation has the benefit that there is no combinatory
  explosion of substitutions and renamings, e.g.\ no extra lemmas have to be
  proved between an expression-in-expression and a type-in-expression
  substitution, because both are simply substitutions.

  % \subsection{The Need for Renamings}
  % \label{sec:maps:renamings}
  % A problem with mechanizing languages with de bruijn indices is that
  % the operation of applying a substitution \ACode{σ} to a term
  % \ACode{t} cannot be defined directly by structural recursion on
  % \ACode{t}.
  % If \ACode{t} is a term like \ACode{\ACon{λx} e},
  % where the subterm \ACode{e} is under a binder, then the variables
  % in \ACode{e} are shifted, i.e.\ the variable \ACode{\ACon{zero}} refers
  % to the variable from the binder, whereas a variable \ACode{\ACon{suc} x}
  % refers to the variable \ACode{x} from outside of the binder.
  % As the terms contained in \ACode{σ} may themselves contain free variables,
  % they need to be shifted, too, before they can be substituted
  % for variables in \ACode{e}. 
  % Shifting the variables in a term is itself a substitution, which maps
  % each variable \ACode{x} to the term \ACode{\ACon{`} (\ACon{suc} x)}.
  % However, applying this shifting substitution to the terms in
  % \ACode{σ} is not structurally recursive, as the terms in \ACode{σ}
  % are not subterms of \ACode{\ACon{λx} e}.

  % The usual workaround is to first define renamings,
  % i.e.\ substitutions that replace variables with variables.
  % In contrast to general substitutions, renamings can be easily
  % shifted: they only contain variables \ACode{x}, which can be
  % shifted by simply taking their successor \ACode{\ACon{suc} x}.
  % As the shifting substitution is a renaming, we can then define substitution,
  % where we apply the shifting \emph{renaming} to the terms in \ACode{σ} when
  % the substitution needs to go under a binder.

  % % The usual workaround is to define renamings first and use them
  % % to weaken the terms in substitutions when going under binders.
  % While this keeps lemmas simple (requiring only structural induction),
  % it duplicates the amount of work as all operations and lemmas have
  % to be defined and proved for both renamings and substitutions.

  \subsection{Unifying Renamings \& Substitutions}
  \label{sec:maps:kits}
  To avoid the duplication between renamings and substitutions,
  McBride\cite{DBLP:journals/jar/BentonHKM12, unpublished:mcbride2005kits}
  introduced the \emph{kit} abstraction.
  % \footnote{
  %   While kits were originally formulated for intrinsically-typed languages,
  %   they nicely extend to our extrinsically-typed multi-sorted syntax, whose
  %   sort-indexing is a form of intrinsic typing.
  % }
  % A \ACode{Kit} is a structure that captures the commonalities
  % between variables and terms:
  A kit is a structure that allows to abstract over whether
  something is a term or a variable. The intention is to instantiate
  this structure exactly twice (once for variables and once for terms),
  and then write definitions, which are parameterized over a kit and
  consequently can be used for both variables and terms.
  \LibCode\KKit

  As we intend to have exactly two \ACode{\ACon{Kit}} instances, we choose names of
  the form \ACode{x/y}, where \ACode{x} is the name we choose for the
  variable instance, and \ACode{y} is the name we choose for the term
  instance.
  For example the parameter type \ACode{\_∋/⊢\_} will be instantiated
  to \ACode{\ACon{\_∋\_}} for the variable kit, and to \ACode{\AField{\_⊢\_}} for the
  term kit.

  A kit consists of the following components:
  \begin{itemize}
  \item 
    \ACode{\AField{id/`}} converts a variable \ACode{S \ACon{∋} s} into a
    \ACode{S \AField{∋/⊢} s}. For the variable kit, \ACode{S ∋/⊢ s} is instantiated to \ACode{S \ACon{∋} s}, so this
    operation is the identity. For the term kit, \ACode{S ∋/⊢ s} is
    instantiated to \ACode{S \AField{⊢} s}, so this operation is the
    variable constructor \ACode{\AField{`\_}}.
  \item 
    \ACode{\AField{`/id}} converts a \ACode{S ∋/⊢ s} into a term \ACode{S \AField{⊢} s}
    and is analogous to the \ACode{\AField{id/`}} operation.
  \item 
    \ACode{\AField{wk}} shifts the de Bruin indices in a variable or term.
    The new, unused variable \ACode{\ACon{zero}} can assume any sort \ACode{s'}.
    For variables, \ACode{\AField{wk}} is the successor \ACode{\ACon{suc}}.
    For terms, \ACode{\AField{wk}} means applying a shifting renaming to the term.
  \item \ACode{\AField{`/`-is-`}} states that converting a variable first to a ``variable-or-term'' and
    then further to a term is the same as converting it directly to a
    term using the variable constructor \ACode{\AField{`\_}}.
  \item \ACode{\AField{`/id-injective}} and \ACode{\AField{id/`-injective}} state that
    \ACode{\AField{`/id}} and \ACode{\AField{id/`}} are injective.
    % This property
    % follows easily, as both the identity function and the variable
    % constructor are injective.
  \item \ACode{\AField{wk-id/`}} characterizes the behaviour of the
    \ACode{\AField{wk}} function by how it acts on variables:
    injecting a variable and then shifting it, is the same as injecting a shifted variable.
  \end{itemize}

  \begin{figure}
    \centering
    \begin{minipage}[t]{0.5\linewidth}
    \LibCode\KMap
    \LibCode\KAp
    \LibCode\KLiftAlt
    \LibCode\KSingleAlt
    \end{minipage}
    \begin{minipage}[t]{0.4\linewidth}
    \LibCode\KWeakenAlt
    \LibCode\KEq
    \LibCode\KFunExt
    \LibCode\KId
    \LibCode\KIdLift
    \end{minipage}
    \caption{Map Operations}
    \label{fig:map-ops}
  \end{figure}
  Figure~\ref{fig:map-ops} shows the usual operations for renamings and substitutions.
  The definitions are included directly in the record module of the
  Kit, so they are implicitly parameterized over a kit.
  The type \ACode{S₁ \ADef{→ₖ} S₂} unifies
    renamings \ACode{S₁ \ADef{→ᵣ} S₂} and
    substitutions \ACode{S₁ \ADef{→ₛ} S₂}.
    We call a value of type \ACode{S₁ \ADef{→ₖ} S₂} a \emph{map} and
    use the meta-variable \ACode{ϕ} for it.
  The operation \ACode{ϕ \ADef{\&} x} applies a map to a variable.
  The operation \ACode{ϕ \ADef{↑} s} lifts a map under a binder of sort \ACode{s}.
  The operation \ACode{\ADef{⦅} x/t \ADef{⦆}} constructs a singleton map that replaces
  \ACode{\ACon{zero}} with \ACode{x/t} and decreases all other variables by one.
  The \ACode{\ADef{weaken}} map increases all variables by one.
  The \ACode{ϕ₁ \ADef{$\sim$} ϕ₂} type expresses extensional equality of maps.
    For simplicity, we postulate functional extensionality \ACode{\AField{$\sim$-ext}}.\footnote{
      The actual implementation does \emph{not} use any postulates.
      % The workaround is explained in Appendix~\ref{sec:fun-ext}.
    }
  There is an identity map \ACode{\ADef{id}}.
  The lemma \ACode{\ADef{id↑-id}} states that a lifted identity map is again an identity map.

  To make it easier to talk about a specific kit, we introduce the following notations:
  % We also specify notation 
  % to explicitly pass a particular \ACode{\ACon{Kit}} to those definitions:
  % We also specify notation, which makes it less cumbersome
  % to explicitly pass a particular \ACode{\ACon{Kit}} to those definitions:
  \begin{itemize}
  \item
    we write \ACode{S₁ \ADef{–[} K \ADef{]→} S₂} for the \ACode{S₁ \ADef{→ₖ} S₂}
    of some specific \ACode{\ACon{Kit}} \ACode{K}.
  \item
    we write \ACode{S \ADef{∋/⊢[} K \ADef{]} s} for the \ACode{S ∋/⊢ s}
    of some specific \ACode{\ACon{Kit}} \ACode{K}; and
  \end{itemize}

  The operation of applying a map to a term depends on the concrete
  object language. It is captured by the following structure:
  \LibCode\KTraversal
  \noindent The fields of this structure have the following meaning:
  \begin{itemize}
  \item
    \ACode{t \AField{⋯} ϕ} applies the map \ACode{ϕ} (a renaming or
    substitution) to the term \ACode{t}.
  \item
    \ACode{\AField{⋯-var}} states that applying a map \ACode{ϕ} to a variable
    term \ACode{\AField{`} x}, is the same as applying \ACode{ϕ} to
    the variable \ACode{x}, and then converting the result to a term
    via \ACode{\AField{id/`}}.
  \item
    \ACode{\AField{⋯-id}} states that applying the identity map
    \ACode{id} to a term does not change the term.
  \end{itemize}

  Finally, we define the actual kit instances.
  The variable kit definition is straightforward:
  \LibCode\KKitVar

  The term kit requires both the variable kit and the
  \ACode{\ACon{Traversal}} to be defined, because shifting a term with \ACode{\AField{wk}}
  means applying the shifting renaming to the term.
  Hence, we define the term kit in the record module of \ACode{\ACon{Traversal}}:
  \LibCode\KKitTerm

  % The only task left now is to create the two instances for the kits
  % and define how a map can be applied to a term.
  % While the variable kit can be defined as expected, the term kit
  % raises a dependency problem: The \ACode{\AField{wk}} operation for terms requires us
  % to already know how to apply a renaming to term.
  % To solve this problem, McBride came up with a clever solution:
  % Applying a map to a term, can be defined without even having any Kit-instances yet.
  % Afterwards we can first define the variable kit, and in the
  % definition of the term kit, we are then already allowed to apply renamings.
  % After the definition of the term-kit we are then allowed to apply
  % both renamings and substitutions as both kits defined.

  \subsection{Instantiation for System F}
  In this subsection, we show how to instantiate the
  \ACode{\ACon{Traversal}} abstraction for System F.
  In practice, this is done by our reflection algorithm automatically,
  but it can be instructive to see what happens under the hood.

  First, we define the operation of applying a map to a term:
  \AppCode\FTraversalOp
  The interesting cases are those with variables and binders:
  \begin{itemize}
  \item 
    In the variable case \ACode{(\ACon{`} x) \ADef{⋯} ϕ}, we first apply the map
    \ACode{ϕ} to the variable \ACode{x}. If \ACode{ϕ} is a renaming,
    we get back a variable and need to apply the variable constructor
    \ACode{\ACon{`\_}}. If \ACode{ϕ} is a substitution,
    we get back a term that we can use directly.
    This is exactly what \ACode{\AField{`/id}} does.
  \item 
    In cases where the operation needs to go under a binder, like
    \ACode{(\ACon{λx} e) \ADef{⋯} ϕ}, we lift the map using
    \AField{\_↑\_} to account for the bound variable before
    we apply it to the subterm.
  \end{itemize}

  We then prove that applying an identity map does not change the term:
  \AppCode\FTraversalId
  \AppCode\FTraversalIdProofInteresting
  We only display and discuss the interesting cases:
  \begin{itemize}
  \item
    in the variable case \ACode{\ACon{`} x}, the
    \ACon{\AField{id/`}} from the identity map meets the \ACon{\AField{`/id}}
    from the traversal operation, so we need to use \ACon{\AField{`/`-is-`}}.
  \item
    in the lambda abstraction case \ACode{\ACon{λx} e}, the
    traversal lifts the identity under its binder. Here
    we need to use \ACon{\AField{id↑-id}} to show that a lifted identity
    map is again an identity map.
  \end{itemize}

  Finally, we instantiate the \ACode{\ACon{Traversal}} structure:
  % \LibCode\FTraversalIdProofRest
  \AppCode\FTraversal
  
  % \subsection{Unused}
  % \ExampleCode\FExampleTrav
  % \LibCode\KKitOpenInst
  % \LibCode\KKitOpen

  \subsection{Extension Kits}
  \label{sec:maps:wkkit}

  % Before we define \ACode{\ACon{CKit}} and
  % \ACode{\ACon{CTraversal}}, we need one more ingredient.

  As we defined the \ACode{\ACon{Kit}} structure before the
  \ACode{\ACon{Traversal}} structure, the fields of
  \ACode{\ACon{Kit}} could not use map application \ACode{\AField{\_⋯\_}} in
  their types.
  This prevented us to include another useful axiom into the
  \ACode{\ACon{Kit}} structure. As this axiom also needs to be proved
  separately for variables and terms, we define a new structure for
  it which extends a \ACode{\ACon{Kit}}:
  \LibCode\KWkKit
  \noindent The \ACode{\AField{wk-`/id}} axiom
  explains the \ACode{\AField{wk}} function by how it acts on \emph{terms}.
  It is the counterpiece to the \ACode{\ACon{Kit}} axiom
  \ACode{\AField{wk-id/`}}, which explains the \ACode{\AField{wk}}
  function by how it acts on \emph{variables}.
  %
  This lemma is useful for proving extensional equalities between maps
  involving weakening, where \ACode{\AField{`/id-injective}} allows to
  add \ACode{\AField{`/id}} on both sides of the equation, such that
  \AField{wk-`/id} can be used to make further progress.
  %
  The instantiations of the \ACode{\ACon{WkKit}} are straightforward:
  \LibCode\KWkKitInstances

  As the variable and term \ACode{\ACon{Kit}}s are the only two \ACode{\ACon{Kit}}s,
  and both have \ACode{\ACon{WkKit}} instances, it is always safe to assume that
  a \ACode{\ACon{Kit}} also supports the \ACode{\ACon{WkKit}} extension.

  \section{Map Composition}
  \label{sec:composition}

  % - Reason about multiple applications in terms of a single application
  % - e.g. wk-cancels-⦅⦆ or dist-↑-⦅⦆, often important for induction hypothesis
  % - Mcbride uses tactics
  % - We introduce an abstraction similar to kits
  % - CKit has primitives for composition, CTraversal has the property

  %%%%%%%%%%

  In this section, we extend our framework with an abstraction that
  allows the composition of arbitrary maps.
  The core property of composition is the
  \ACode{\AField{fusion}} lemma, which states that applying two maps \ACode{ϕ₁}
  and \ACode{ϕ₂} in sequence to a term \ACode{t}, is the same as
  applying their composition \ACode{(ϕ₁~\AField{·ₖ}~ϕ₂)} to \ACode{t},
  i.e.\ \ACode{(t \AField{⋯} ϕ₁) \AField{⋯} ϕ₂ \ACon{≡} t \AField{⋯} (ϕ₁ \AField{·ₖ} ϕ₂)}.
  % $$
  % \ACode{(t \AField{⋯} ϕ₁) \AField{⋯} ϕ₂ \ACon{≡} t \AField{⋯} (ϕ₁ \AField{·ₖ} ϕ₂)}
  % $$
  This property gives our framework the ability to
  reason about the application of multiple maps by reasoning about
  the application of a single map.
  As such it forms the basis for all lemmas involving multiple maps,
  e.g.\ that applying a weakening and then a singleton
  substitution cancel each other out.
  
  % For example, we can prove that first applying a weakening
  % \ACode{\ADef{weaken} s}, and then applying a singleton substitution
  % \ACode{\ADef{⦅} t \ADef{⦆}} cancel each other cancel each other out
  % by proving that
  % \ACode{(\ADef{weaken} s \AField{·ₖ} \ADef{⦅} t \ADef{⦆}) \ADef{$\sim$} id}.
  % As such it forms the basis for proving that a shifting cancels a
  % singleton substitution, or that 

  % For many lemmas, e.g. substitution-preserves-typing in System F,
  % it is necessary to apply an equality like \ACode{t ⋯ σ₁ ⋯ σ₂ ≡ t ⋯ σ₂' ⋯ σ₁'}
  % where the induction hypothesis requires \ACode{t' ⋯ σ₁'}.

  % Composition of substitutions is important for most language
  % formalizations, as it allows to reason about the meaning of applying
  % multiple substitutions to a term. This appears for example in the proof of
  % substitution-preserves-typing for System F, where in the
  % case of type-application \ACode{(e \ACon{∙} t) \ADef{⋯} σ} we need to reason about
  % \ACode{(e \ADef{⋯} \ADef{⦅} t \ADef{⦆}) \ADef{⋯} σ}, which is equivalent to
  % \ACode{e \ADef{⋯} (\ADef{⦅} t \ADef{⦆} \ADef{·ₖ} σ)},
  % where \ACode{\_\ADef{·ₖ}\_} is backward composition.

  As we defined substitution in terms of renamings, we need to
  consider all four compositions between renamings and substitutions.
  While the composition operations can be defined independently of each other,
  the \ACode{\AField{fusion}} lemma for two substitutions, depends on the
  \ACode{\AField{fusion}} lemmas for a renaming and a substitution, which in
  turn depend on the \ACode{\AField{fusion}} lemma for two renamings.

  Previous work on kits\cite{DBLP:journals/jar/BentonHKM12} addresses this
  issue by duplicating the definitions and using tactics to reduce
  boilerplate in proofs.
  In contrast, we define structures similar to \ACode{\ACon{Kit}} and
  \ACode{\ACon{Traversal}}, which allow us to abstract over all four
  compositions and use the same trick as before to eliminate the
  dependencies.
  With the help of a general map composition, we can prove lemmas
  about the interactions of general maps, which is crucial for proving a
  type preservation lemma for general map application instead of individual
  lemmas for renamings and substitutions.

  \subsection{An Examination of Composition}
  \label{sec:composition:example}
  To motivate our abstraction, we first look
  at the four compositions individually:

  \noindent
  \begin{minipage}[t]{0.65\linewidth}
  \ExampleCode\KExFourCompsI
  \end{minipage}
  \begin{minipage}[t]{0.35\linewidth}
  \ExampleCode\KExFourCompsII
  \end{minipage}

  The definitions reveal two interesting properties:
  \begin{enumerate}
  \item
    If we compose two maps \ACode{ϕ₁} and \ACode{ϕ₂}, then the
    resulting map is a renaming, iff both \ACode{ϕ₁} and \ACode{ϕ₂} are
    renamings.
    In other words:
    if \ACode{ϕ₁} is a \ACode{K₁}-map and \ACode{ϕ₂} is a \ACode{K₂}-map,
    then the result is a \ACode{(K₁ ⊔ K₂)}-map, where \ACode{⊔} refers to the
    lattice for \ACode{\{ \ADef{Kᵣ} , \ADef{Kₛ} \}}
    generated by \ACode{\ADef{Kᵣ} < \ADef{Kₛ}}.
  \item
    All four compositions first apply \ACode{ϕ₁} to \ACode{x},
    and then apply \ACode{ϕ₂} to the result.
    If \ACode{ϕ₁} is a renaming, this result is another variable, but
    if \ACode{ϕ₁} is a substitution, this result is a term.
  \end{enumerate}
  With the \ACode{\ACon{Kit}} abstraction, we can easily abstract over
  \ACode{ϕ₂} being a renaming or a substitution:

  \noindent
  \begin{minipage}[t]{0.65\linewidth}
  \ExampleCode\KExTwoCompsI
  \end{minipage}
  \begin{minipage}[t]{0.35\linewidth}
  \ExampleCode\KExTwoCompsII
  \end{minipage}

  \noindent But to abstract over \ACode{ϕ₁}, the \ACode{\ACon{Kit}} abstraction
  is not sufficient: while it allows us to abstract over what we are applying, i.e.
  a renaming or a substitution, it does not allow us to
  abstract over what we are applying it to, i.e.\ a variable or a term.
  For the latter we have two distinct operations \ACode{\ADef{\_\&\_}}
  and \ACode{\ADef{\_⋯\_}}.

  To fill this gap, we introduce a new abstraction that we call a
  \emph{compose kit} (\ACode{\ACon{CKit}}),
  which provides an operation \ACode{\AField{\_\&/⋯\_}} that unifies
  \ACode{\ADef{\_\&\_}} and \ACode{\ADef{\_⋯\_}}. This allows us to
  define a general composition as follows:
  \ExampleCode\KComposition

  % \ACode{\ACon{CKit}} and \ACode{\ADef{\_·ₖ\_}} are analogous to
  % \ACode{\ACon{Kit}} and \ACode{\ADef{\_→ₖ\_}}, whereas
  % \ACode{\ACon{CTraversal}} and \ACode{\AField{fusion}} are analogous to
  % \ACode{\ACon{CTraversal}} and \ACode{\AField{\_⋯\_}}.
  
  \subsection{An Abstraction for Composition}
  \label{sec:composition:ckit}

  A compose kit \ACode{\ACon{CKit}~K₁~K₂~K₁⊔K₂}
  describes the operations necessary for definining the composition of a
  \ACode{K₁}-map with a \ACode{K₂}-map that results in a \ACode{K₁⊔K₂}-map:
  \LibCode\KCKit
  \noindent The third parameter \ACode{K₁⊔K₂} can be seen as a functional
  dependency\cite{DBLP:conf/esop/Jones00} and is determined
  by the choice of \ACode{K₁} and \ACode{K₂}.
  The fields of a compose kit have the following meaning:
  \begin{itemize}
  \item
    The \ACode{\AField{\_\&/⋯\_}} operation takes a variable or term
    \ACode{x/t} (according to \ACode{K₁}) and a renaming or substitution
    \ACode{ϕ} (according to \ACode{K₂}) and applies \ACode{ϕ} to \ACode{x/t} resulting in
    a variable or term (according to \ACode{K₁⊔K₂}).
    From this operation we derive map composition \ACode{\ADef{\_·ₖ\_}} as
    shown in the previous subsection.
    % We use the notation \ACode{ϕ₁ \ADef{·[} C \ADef{]} ϕ₂}, if we need to
    % make it explicit that we are using the composition of some
    % specific \ACode{\ACon{CKit}} \ACode{C}.
  \item 
    The \ACode{\AField{\&/⋯-⋯}} lemma describes the behavior of
    \ACode{\AField{\_\&/⋯\_}} in terms of \ACode{\AField{\_⋯\_}}, allowing
    subsequent lemmas to make use of the lemmas that we have already proved
    for \ACode{\AField{\_⋯\_}}.
  \item 
    The \ACode{\AField{\&/⋯-wk-↑}} lemma states that applying a map and then
    weakening is the same as weakening first and then lifting the map over
    the variable introduced by the weakening.
    From this lemma, we can derive that lifting distributes over composition:
    \LibCode\KDistLiftCompose
    % \LibCode\KDistLiftComposeProof
  \end{itemize}

  A \ACode{\ACon{CTraversal}} provides a \ACode{\AField{fusion}} lemma
  that works for the composition of any \ACode{\ACon{CKit}}:
  \LibCode\KCTraversal

  \noindent Given a \ACode{\ACon{CTraversal}}, we can prove the usual lemmas about interactions
  of multiple maps:
  \begin{itemize}
  \item 
    A map \ACode{ϕ} followed by a weakening is equivalent to a
    weakening followed by \ACode{ϕ} that has been lifted over the weakened
    variable:
    \LibCode\KCommLiftWeakenTraverse

    % A map \ACode{ϕ} followed by a weakening is equivalent to a
    % weakening followed by \ACode{ϕ} that has been lifted over the weakened
    % variable:
    % \LibCode\KCommLiftWeaken
    % % \LibCode\KCommLiftWeakenProof
    % By applying \ACode{\AField{fusion}} to this lemma, we get the same
    % statement for multiple map applications:
    % \LibCode\KCommLiftWeakenTraverse
    % % \LibCode\KCommLiftWeakenTraverseProof
  \item 
    A weakening followed by a singleton substitution act as an identity map:
    \LibCode\KWeakenCancelsSingleTraverse

    % A weakening followed by a singleton substitution cancel each other out:
    % \LibCode\KWeakenCancelsSingle
    % % \LibCode\KWeakenCancelsSingleProof
    % By applying \ACode{\AField{fusion}} and \ACode{\AField{⋯-id}} to
    % this lemma, we get the same statement for multiple map applications:
    % \LibCode\KWeakenCancelsSingleTraverse
    % % \LibCode\KWeakenCancelsSingleTraverseProof
  \item 
    A singleton map can be swapped with any map \ACode{ϕ}:
    \LibCode\KDistLiftSingleTraverse
    % A singleton map can be swapped with any map \ACode{ϕ}:
    % \LibCode\KDistLiftSingle
    % % \LibCode\KDistLiftSingleProof
    % By applying \ACode{\AField{fusion}} to this lemma, we get the
    % same statement for multiple map applications:
    % \LibCode\KDistLiftSingleTraverse
    % % \LibCode\KDistLiftSingleTraverseProof
  \end{itemize}
  Similarly, as it was the case for the \ACode{\ADef{Kit}} and \ACode{\ADef{Traversal}}
  structures, the idea is that we instantiate the \ACode{\ADef{CTraversal}} for
  our object language, and in return the framework defines the concrete \ACode{\ADef{CKit}}
  instances for us. Hence, we define the \ACode{\ADef{CKit}} instances in the record module of \ACode{\ADef{CTraversal}}:
  \LibCode\KCKitInstances
  \noindent
  \ACode{\ADef{Cᵣ}} is the compose kit between a renaming and another kit \ACode{K}.
  \ACode{\ADef{Cₛ}} is the compose kit between a substitution and another kit \ACode{K},
  and requires that we already know how to compose a \ACode{K}-map with a renaming.
  The following verifies that \ACode{\ADef{Cᵣ}} and \ACode{\ADef{Cₛ}} indeed get us all four compositions:

  \noindent
  \begin{minipage}[t]{0.244\linewidth}
  \ExampleCode\KCKitInstancesConcreteI
  \end{minipage}
  \begin{minipage}[t]{0.244\linewidth}
  \ExampleCode\KCKitInstancesConcreteII
  \end{minipage}
  \begin{minipage}[t]{0.244\linewidth}
  \ExampleCode\KCKitInstancesConcreteIII
  \end{minipage}
  \begin{minipage}[t]{0.244\linewidth}
  \ExampleCode\KCKitInstancesConcreteIV
  \end{minipage}

  % To get the \ACode{\ADef{CKit}} between substitutions and
  % renamings, the argument \ACode{\ADef{Cᵣ}} is used.
  % The resulting \ACode{\ADef{CKit}} is then again used as an argument
  % for \ACode{\ADef{Cₛ}} to yield the \ACode{\ADef{CKit}}
  % between two substitutions. As shown below, Agda's instance
  % resolution is up for the task:

  % \noindent
  % \begin{minipage}[t]{0.5\linewidth}
  % \LibCode\KCKitInstancesConcreteI
  % \end{minipage}
  % \begin{minipage}[t]{0.5\linewidth}
  % \LibCode\KCKitInstancesConcreteII
  % \end{minipage}

  % \LibCode\KCKitNotation


  % \subsection{An Abstraction for Composition}
  % \label{sec:composition:ckit}

  % In this subsection, we define the \ACode{\ACon{CKit}}
  % abstraction, which provides the \ACode{\AField{\_\&/⋯\_}} operation
  % that is necessary for defining composition, and the
  % \ACode{\ACon{CTraversal}}, which provides the
  % \ACode{\AField{fusion}} lemma for general maps.

  % Similarly as it was the case for \ACode{\ACon{Kit}} and \ACode{\ACon{Traversal}},
  % the lemma of the \ACode{\ACon{CTraversal}} needs to be proved for
  % an abstract \ACode{\ACon{CKit}} and in return defines the
  % four concrete \ACode{\ACon{CKit}} instances for us. This allows us to break
  % the dependencies between the different \ACode{\AField{fusion}} lemmas,
  % similar to how \ACode{\ACon{Kit}} and \ACode{\ACon{Traversal}} allowed
  % us to break the dependency between traversals with renamings and substitutions.

  % For this purpose, the \ACode{\ACon{CKit}} abstraction, needs
  % to satisfy two requirements:
  % it needs to provide us with enough machinery to define composition, but
  % it also needs to provide us with enough axioms that we are able to instantiate
  % the \ACode{\ACon{CTraversal}}. It is defined as followed:
  % \LibCode\KCKit
  % The \ACode{\AField{\_\&/⋯\_}} operation takes a variable or term
  % (according to \ACode{K₁}) and a renaming or substitution
  % (according to \ACode{K₂}) and performs the map traversal returning
  % a variable or term (according to \ACode{K₁⊔K₂}).
  % The third parameter \ACode{K₁⊔K₂} can be seen as a functional
  % dependency\cite{DBLP:conf/esop/Jones00} and is determined
  % by the choice of \ACode{K₁} and \ACode{K₂}.

  % The \ACode{\AField{\&/⋯-⋯}} lemma describes the behavior of
  % \ACode{\AField{\_\&/⋯\_}} in terms of \ACode{\AField{\_⋯\_}}, allowing
  % subsequent lemmas to make use of the lemmas that we have already proved
  % for \ACode{\AField{\_⋯\_}}.

  % The \ACode{\AField{\&/⋯-wk-↑}} lemma states that applying a map and then
  % weakening is the same as weakening first and then lifting the map over
  % the variable introduced by the weakening.

  % Similar as for the \ACode{\ACon{Kit}}, we derive further definitions
  % from the axioms of a \ACode{\ACon{CKit}}:
  % \begin{itemize}
  % \item
  %   We define map composition as motivated by the previous subsection:
  %   \LibCode\KComposition
  % % \item
  % %   We show that the \ACode{\AField{\_\&/⋯\_}} operator behaves like
  % %   \ACode{\AField{\_\&\_}} when applied to variables:
  % %   \LibCode\KCKitAp
  % %   % \LibCode\KCKitApProof

  % %   % The \ACode{\AField{`/id}} on the left side is from \ACode{K₁⊔K₂}, whereas
  % %   % the \ACode{\AField{`/id}} on the right side is from \ACode{K₂}.
  % \item
  %   We show that lifting \ACode{\AField{\_↑\_}} distributes over
  %   composition:
  %   \LibCode\KDistLiftCompose
  %   % \LibCode\KDistLiftComposeProof
  % \end{itemize}
  % % To make it easier to explicitly specify a \ACode{\ACon{CKit}},
  % % we define the notation \ACode{ϕ₁ \ADef{·[} C \ADef{]} ϕ₂}
  % % to stand for \ACode{ϕ₁ \ADef{·ₖ} ϕ₂} for some
  % % \ACode{\ACon{CKit}} \ACode{C}.
  % % \LibCode\KCKitNotation

  % We then define a structure,
  % which provides the \ACode{\AField{fusion}} lemma for arbitrary
  % \ACode{\ACon{CKit}}s:
  % \LibCode\KCTraversal

  % Similar as for the \ACode{\ACon{Traversal}}, we derive further
  % definitions from the axioms of a \ACode{\ACon{CTraversal}}:
  % \begin{itemize}
  % \item 
  %   A map \ACode{ϕ} followed by a weakening is equivalent to a
  %   weakening followed by \ACode{ϕ} that has been lifted over the weakened
  %   variable:
  %   \LibCode\KCommLiftWeakenTraverse

  %   % A map \ACode{ϕ} followed by a weakening is equivalent to a
  %   % weakening followed by \ACode{ϕ} that has been lifted over the weakened
  %   % variable:
  %   % \LibCode\KCommLiftWeaken
  %   % % \LibCode\KCommLiftWeakenProof
  %   % By applying \ACode{\AField{fusion}} to this lemma, we get the same
  %   % statement for multiple map applications:
  %   % \LibCode\KCommLiftWeakenTraverse
  %   % % \LibCode\KCommLiftWeakenTraverseProof
  % \item 
  %   A weakening followed by a singleton substitution cancel each other out:
  %   \LibCode\KWeakenCancelsSingleTraverse

  %   % A weakening followed by a singleton substitution cancel each other out:
  %   % \LibCode\KWeakenCancelsSingle
  %   % % \LibCode\KWeakenCancelsSingleProof
  %   % By applying \ACode{\AField{fusion}} and \ACode{\AField{⋯-id}} to
  %   % this lemma, we get the same statement for multiple map applications:
  %   % \LibCode\KWeakenCancelsSingleTraverse
  %   % % \LibCode\KWeakenCancelsSingleTraverseProof
  % \item 
  %   A singleton map can be swapped with any map \ACode{ϕ}:
  %   \LibCode\KDistLiftSingleTraverse
  %   % A singleton map can be swapped with any map \ACode{ϕ}:
  %   % \LibCode\KDistLiftSingle
  %   % % \LibCode\KDistLiftSingleProof
  %   % By applying \ACode{\AField{fusion}} to this lemma, we get the
  %   % same statement for multiple map applications:
  %   % \LibCode\KDistLiftSingleTraverse
  %   % % \LibCode\KDistLiftSingleTraverseProof
  % \item 
  %   We define \ACode{\ACon{CKit}} instances for each of the four
  %   combinations between renamings and substitutions:
  %   \LibCode\KCKitInstances
  %   Interestingly, the \ACode{\ADef{Cₛ}} instance has another
  %   \ACode{\ADef{CKit}} parameter.
  %   This allows us to first use \ACode{\ADef{Cᵣ}} as an argument,
  %   which yields the \ACode{\ADef{CKit}} between substitutions
  %   and renamings, and then use this resulting \ACode{\ADef{CKit}}
  %   as an argument for the case with two substitutions.
  %   As shown below, Agda's instance resolution is up for the task:

  %   % To get the \ACode{\ADef{CKit}} between substitutions and
  %   % renamings, the argument \ACode{\ADef{Cᵣ}} is used.
  %   % The resulting \ACode{\ADef{CKit}} is then again used as an argument
  %   % for \ACode{\ADef{Cₛ}} to yield the \ACode{\ADef{CKit}}
  %   % between two substitutions. As shown below, Agda's instance
  %   % resolution is up for the task:
  %   \begin{minipage}[t]{0.5\linewidth}
  %   \LibCode\KCKitInstancesConcreteI
  %   \end{minipage}
  %   \begin{minipage}[t]{0.5\linewidth}
  %   \LibCode\KCKitInstancesConcreteII
  %   \end{minipage}

  % \end{itemize}

  \subsection{Instantiation for System F}
  In this subsection, we show how to instantiate the
  \ACode{\ACon{CTraversal}} abstraction for System F.
  In practice, this is done by our reflection algorithm automatically,
  but it can be instructive to see, as it motivates the axioms of the
  \ACode{\ACon{CKit}}.

  \AppCode\FFusion
  \AppCode\FFusionProofInteresting
  We only show the interesting cases, which are:
  \begin{itemize}
  \item
    variables, where we need to use the \ACode{\AField{\&/⋯-⋯}} lemma
    provided by the \ACode{\ACon{CKit}}; and
  \item
    bindings, where the traversal operation \ACode{\AField{\_⋯\_}}
    needs to lift the map via \ACode{\AField{\_↑\_}}, requiring us to
    distribute the lifting over the composition using
    \ACode{\AField{dist-↑-·}}.
  \end{itemize}

  % \AppCode\FFusionProofRest
  % \AppCode\FCTraversal

  \section{Types \& Typing}
  \label{sec:types}
  \subsection{Types}
  % To define type contexts and a typing relation, we need to know
  % which sorts of terms play the role of types for other sorts of terms.
  % When modeling a typed language with multi-sorted syntax, both terms
  % and types are represented as terms, but with different sorts.
  % To define type contexts and a typing relation, we need to record for each term
  % from 
  % describe terms, and ocan be mapped to 
  % In a typed language,

  In the context of multi-sorted syntax, the notion of a type can be
  described as a mapping between sorts.
  For System F, the expression sort \ACode{\ACon{𝕖}} maps to the type sort
  \ACode{\ACon{𝕥}}, and the sort \ACode{\ACon{𝕥}} maps to the kind sort
  \ACode{\ACon{𝕜}}.
  The following structure is used to teach our framework about types:
  \LibCode\KTypeSorts
  For System F, the instantiation is
  \AppCode\FTypes
  There are two things to discuss:
  \begin{enumerate}
  \item
    The \ACode{\AField{↑ᵗ}} function maps a sort of arbitrary sort type,
    to a sort of a potentially different sort type, which is expressed
    by the use of an existential.
    For System F we require this generality, as the sort
    \ACode{\ACon{𝕥}} can have variables, whereas its corresponding type
    sort \ACode{\ACon{𝕜}} cannot.
  \item
    Some sorts, like \ACode{\ACon{𝕜}}, do not have corresponding type
    sorts, but we still need to provide one, as \ACode{\AField{↑ᵗ}} is a
    total function.
    For such sorts, we can simply use arbitrary sort types, as the
    formalization will have no typing rules that use them.
  \end{enumerate}
  To hide the existential, we define \ACode{S \ACon{∶⊢} s}, which represents
  the type for a term \ACode{S \ACon{⊢} s}.
  \LibCode\KTypes

  \subsection{Type Contexts}
  Equipped with a notion of types, we are ready to define type contexts.
  As we want our framework to support dependent types, we allow a type
  in the context to use all variables bound previously in the context:
  \LibCode\KContexts

  When looking up the type of a variable, we need to weaken it for each
  binding that comes after the variable:
  \LibCode\KContextLookup

  % Finally, we define a variable typing:
  Finally, a variable typing \ACode{Γ \ADef{∋} x \ADef{∶} t}
  states that looking up \ACode{x} in \ACode{Γ} yields \ACode{t}:
  \LibCode\KVariableTyping

  \subsection{Typing}
  \label{sec:types:typing}
  Now that we have a notion of types and type contexts, we are ready to define
  the multi-sorted typing relation for System F, which describes both
  typing and kinding:
  \AppCode\FTyping

  % \begin{minipage}[b]{0.5\linewidth}
  % \AppCode\FTypingI
  % \end{minipage}
  % \begin{minipage}[b]{0.5\linewidth}
  % \AppCode\FTypingII
  % \end{minipage}

  The interesting cases are:
  \begin{itemize}
  \item
    the variable rule \ACode{\ACon{⊢`}}, which covers both expression- and
    type-variables, analogously to the variable term constructor;
  \item
    the lambda rule \ACode{\ACon{⊢λ}}, which
    weakens the codomain type \ACode{t₂}.
    This is necessary, because multi-sorted syntax allows types
    to depend on expressions, so the typing derivation for \ACode{e}
    has to account for a variable, which is not used by the type; and
  \item
    the kinding rule \ACode{\ACon{⊢τ}} states that all types
    have kind \ACode{\ACon{★}}. This is sufficient for System F as types
    are automatically well-kinded due to intrinsic scoping.
  \end{itemize}
  To teach the framework about typing, we create a structure analogously to
  \ACode{\ACon{Syntax}}:
  \LibCode\KTyping
  The instantiation for System F is straightforward:
  \AppCode\FTypingInst

  \subsection{An Abstraction for Type Preservation}
  By now, the reader probably knows what comes next: we build an
  abstraction to unify type preservation for renamings and substitutions,
  eliminating the dependencies by yet another type of kits.

  We start with \ACode{\ACon{TKit}}s, which abstract over
  variable and term \emph{typing}, and then define a
  \ACode{\ACon{TTraversal}}, which provides
  substitution-preserves-typing for all \ACode{\ACon{TKit}}s.
  \LibCode\KTKit
  The first field abstracts over variable and term typing.
  The other fields express typings for the fields of a \ACode{\ACon{Kit}}.
  Building on the fields of a \ACode{\ACon{TKit}}, we define map
  typing and type preservation for map lifting and the singleton map
  in the record module of \ACode{\ACon{TKit}}:
  \begin{itemize}
  \item
    Using the variable/term typing, we can define a renaming/substitution typing:
    \LibCode\KMapTyping
    \ACode{ϕ \ADef{∶} Γ₁ \ADef{⇒ₖ} Γ₂} states that \ACode{ϕ} is a map that takes
    terms from \ACode{Γ₁} to terms in \ACode{Γ₂}.
  \item 
    Lifting a map preserves its typing:
    \LibCode\KLiftTyping
    % \LibCode\KLiftTypingProof
  \item 
    If a variable/term has a typing, then so does its singleton renaming/substitution:
    \LibCode\KSingleTyping
    % \LibCode\KSingleTypingProof
  \end{itemize}
  % To make it easier to explicitly pass typing kits,
  % we define the notation \ACode{ϕ \ADef{∶} Γ₁ \ADef{⇒[} TK \ADef{]} Γ₂}
  % to stand for \ACode{ϕ \ADef{∶} Γ₁ \ADef{⇒ₖ} Γ₂} of some
  % \ACode{\ACon{TKit}} \ACode{TK}.
  % \LibCode\KTypingNotation

  We then define a \ACode{\ACon{TTraversal}} analogously to
  \ACode{\ACon{Traversal}}, but instead of defining the application of
  % maps, it defines that the application of typed maps preserves term types:
  maps, it defines that the application of a typed map to a typed term yields a typed term:
  \LibCode\KTTraversal
  Given a term \ACode{e} with typing \ACode{⊢e} and
  a renaming/substitution \ACode{ϕ} with typing \ACode{⊢ϕ},
  the term \ACode{⊢e \AField{⊢⋯} ⊢ϕ} is a typing for \ACode{e \AField{⋯} ϕ}.

  As before, we define the \ACode{\ACon{TKit}} instances in the record module
  of \ACode{\ACon{TTraversal}}:
  \LibCode\KTypingInstances

  The large amount of kit-parameters of \ACode{\AField{\_⊢⋯\_}} does
  not impose any restriction, as both our \ACode{\ACon{Kit}}s support
  the \ACode{\ACon{WkKit}} extension and can be composed
  arbitrarily. Agda's instance resolution allows us to easily
  instantiate a concrete substitution-preserves-typing lemma:
  \LibCode\KTPresS

  % \noindent
  % \begin{minipage}[t]{0.5\linewidth}
  % \LibCode\KTypingInstancesI
  % \end{minipage}
  % \begin{minipage}[t]{0.5\linewidth}
  % \LibCode\KTypingInstancesII
  % \end{minipage}

  % \LibCode\KTTraversalNotation

  \subsection{Instantiation for System F}
  In this subsection, we show how to instantiate the
  \ACode{\ACon{TTraversal}} abstraction for System F.
  This is the only structure that is \emph{not} instantiated
  automatically via reflection, as typing relations can be arbitrary
  complex in general.

  \AppCode\FPreserve
  The type of \ACode{\ADef{\_⊢⋯\_}} is the same as in the record definition and hence omitted.
  The interesting parts of the proof are:
  \begin{itemize}
  \item
    There is a strong similarity to the instantiation of
    map traversal \ACode{\ADef{\_⋯\_}}: where \ACode{\ADef{\_⋯\_}}
    used \ACode{\AField{`/id}} or \ACode{\AField{\_↑\_}}, our \ACode{\ADef{\_⊢⋯\_}} uses their
    preservation lemmas \ACode{\AField{⊢`/id}} or \ACode{\AField{\_⊢↑\_}}.
  \item
    The lambda typing constructor \ACode{\ACon{⊢λ}} weakens the type \ACode{t₂} to
    shield it from expression-substitution, requiring us to use
    \ACode{\AField{⋯-↑-wk}} to move the map under the weakening.
  \item
    The type application constructor \ACode{\ACon{⊢∙}} substitutes \ACode{t₁} into \ACode{t₂},
    requiring us to use \ACode{\AField{dist-↑-⦅⦆}} to move the map
    under the singleton substitution.
  \end{itemize}
  % Finally, we instantiate the \ACode{\ACon{TTraversal}} structure:
  % \AppCode\FTTraversal

  % As the \ACode{\ACon{Traversal}} and  \ACode{\ACon{CTraversal}} instances
  % can be generally derived via reflection,
  % the \ACode{\AField{\_⊢⋯\_}} lemma is in fact the only lemma that
  % has to been proved manually for subject reduction.
  % From this single lemma follows type preservation for all operations
  % of both renamings and substitutions for all sorts of variables
  % simultaneously.

  % \section{Subject Reduction}
  % \label{sec:subjectreduction}

  % To finish our running example, we define a standard small-step
  % operational semantics for System F with full reduction and prove subject reduction:
  % \AppCode\FReduction
  % \vspace{0mm}
  % \AppCode\FSubjectReduction
  % \AppCode\FSubjectReductionProofInteresting
  % We only list the cases for $\beta$-reduction, as the other cases
  % follow directly from the induction hypothesis:
  % \begin{itemize}
  % \item The $\beta$-reduction rule for type-application, \ACode{\ACon{β-Λ}},
  %   is a direct consequence of substitution-preserves-typing.
  % \item The $\beta$-reduction rule for value-application is almost the same,
  %   but requires us to additionally show that the type is not affected by the
  %   expression substitution.
  %   % This is a direct consequence of the weakening used in \ACode{\ACon{⊢λ}}.
  % \end{itemize}

  % \FSubjectReductionProofRest

  \section{Reflection \& Generics}
  \label{sec:reflection}
  We use Agda's reflection mechanism to derive
  instantiations related to all structures for untyped substitition,
  i.e.\ \ACode{\ACon{Syntax}}, \ACode{\ACon{Traversal}} and
  \ACode{\ACon{CTraversal}}.

  To gain insight into the class of object languages supported by our
  reflection algorithm, we have instantiated the structures for a generic syntax
  similar to the one in Allais et al.\cite{DBLP:journals/pacmpl/AllaisA0MM18}.
  Our reflection algorithm derives proofs with the same
  structure as the generic proofs, giving high confidence that it covers
  the same class of languages. 

  Informally, all objects languages with multi-sorted syntax are supported that
  \begin{enumerate}
  \item have a variable constructor of type
    \ACode{\AKw{∀} \{S s\} \AKw{→} S \ACon{∋} s \AKw{→} S \ACon{⊢} s};
  \item use subterms only directly (e.g. not in lists); and
  \item only extend the scope-context of subterms, but never modify it otherwise.
  \end{enumerate}

  % Appendix~\ref{sec:generic-class} and the actual implementation.

  We believe restriction 2 is purely technical and can be lifted
  with a more sophisticated reflection algorithm. In the current system,
  this restriction can be worked around by inlining the data structure
  constructors into the syntax definition as terms of a new sort.

  The formal definition of the generic syntax can be found in
  the supplementary material.

  % We believe restriction 3 can be lifted partially to allow for
  % example the encoding of linear types that requires context
  % splitting.


  \section{Case Studies}
  \label{sec:casestudies}
  Using our full implementation of the framework, we proved subject
  reduction for the following object languages:
  \begin{itemize}
  \item
    For lambda calculus with dependent function types, the framework
    works out of the box for both deriving untyped substitution
    and instantiating the \ACode{\ACon{TTraversal}}.
    In the proof of confluence, the \ACode{\ACon{CKit}} abstraction
    allowed us to unify lemmas about the reduction of renamings and
    substitutions.
  \item
    For System F with subtyping the main challenges are how to represent
    subtyping constraints and how to deal with the fact that
    substitution-preserves-typing is not generally true, as type variables
    have subtyping bounds that need to be respected.
    While it would be possible to use our framework only to derive
    untyped substitution and define typing contexts and type preservation
    lemmas by hand, we instead used an encoding that allows us to use the
    the \ACode{\ACon{TKit}} abstraction directly.
    Instead of binding a type variable with a subtyping constraint
    \ACode{α <: t}, we first bind the type variable as \ACode{α : ★}, and
    then bind the constraint as \ACode{c ∶ (α <: t)}. This description is
    similar to first-class constraints, but restricted enough to be
    isomorphic to the original formalization, as constraint variables
    cannot be accessed by the user.
    With this encoding, substitution-preserves-typing is generally true
    again: replacing a type variable \ACode{α <: t} with a type \ACode{t'},
    which is not a subtype of \ACode{t}, results in a term that is still
    well-typed, but in a context with an unsatisfiable constraint \ACode{t' <: t}.
  \item
    % Object languages with pattern matching can be encoded by adding
    % the sorts of the variables bound by a pattern to the pattern sort
    % \ACode{\ACon{𝕡}} itself:
    % \begin{quote}
    % \ACode{\ACon{𝕡} \AKw{:} \ACon{List (Sort Var)} \AKw{→} \ACon{Sort NoVar}} 
    % \end{quote}
    % This allows the clause of a \ACode{\ACon{match}} expression to
    % read the bound variables from the pattern sort and make them
    % available as free variables in its body expression.
    Object languages with pattern matching can be modeled by adding
    the sorts of the variables bound by a pattern to the pattern sort
    \ACode{\ACon{𝕡}} itself. A pattern matching clause \ACode{p~\ACon{⇒}~e} can
    then be defined as
    \begin{quote}
    \ACode{\ACon{\_⇒\_} \AKw{:} S \ACon{⊢} \ACon{𝕡} S' \AKw{→} \AKw{(}S' \ADef{++} S\AKw{)} \ACon{⊢} \ACon{𝕖} \AKw{→} S \ACon{⊢} \ACon{𝕔}} 
    \end{quote}
    where \ACode{S'} describes the variables bound by the pattern and \ACode{\ACon{𝕔}} is the sort of a clause.
  \end{itemize}

  \section{Related Work}
  \label{sec:related}

  % Frameworks for programming language metatheory can be broadly
  % categorized by representation of variable bindings and
  % representation of typing and scoping.

  % Variable bindings have been represented as de Bruijn indices, de
  % Bruijn levels, names, locally nameless, locally named, shifted names,
  % nominal techniques, (parameterized) higher order abstract syntax.

  % Typing and scoping can be both extrinsic, both intrinsic, or
  % extrinsically typed and intrinsically scoped.

  As the amount of related work is rather large, we focus on work that
  is closely related to ours and refer to other papers for the
  broader
  picture\cite{DBLP:conf/cpp/StarkSK19,DBLP:journals/pacmpl/AllaisA0MM18}.
  % In
  % particular, we discuss abstractions for renamings
  % and substitutions, comparable extrinsically typed approaches, but also
  % intrinsically typed approaches that could be used as a basis for
  % multi-sorted syntax, which as mentioned before is intrinsically typed
  % in disguise.

  \subsection{Variable Binding}
  There is a plethora of different methods for representing
  variable binders:
  de Bruijn indices\cite{scholar:de1972lambda},
  co de Bruijn indices\cite{DBLP:journals/corr/abs-1807-04085},
  locally nameless\cite{DBLP:journals/jar/Chargueraud12},
  locally named\cite{DBLP:conf/tlca/McKinnaP93},
  higher order abstract syntax\cite{DBLP:conf/pldi/PfenningE88} and
  its parametric variant\cite{DBLP:conf/icfp/Chlipala08},
  nominal logic\cite{DBLP:journals/tcs/UrbanPG04},
  shifted names\cite{scholar:dolansyntax},
  nameless painless\cite{DBLP:conf/icfp/Pouillard11}, and
  scope graphs\cite{DBLP:journals/pacmpl/AntwerpenPRV18}.
  Many of these representations have been studied in solutions to the POPLMark
  challenges\cite{DBLP:conf/tphol/AydemirBFFPSVWWZ05, DBLP:journals/jfp/AbelAHPMSS19}.

  \subsection{Unifying Renamings \& Substitution}

  The kit abstraction for unifying renamings and substitutions
  appeared first in an unpublished manuscript by
  McBride\cite{unpublished:mcbride2005kits}, and later in
  Benton et al.\cite{DBLP:journals/jar/BentonHKM12}. 
  Wood and Atkey\cite{DBLP:journals/corr/abs-2005-02247} propose an
  extension to kits that supports substructural types via resource
  vectors.
  In all three cases kits are formulated for intrinsic typing
  and scenarios with polymorphism are not considered.

  \subsection{Extrinsically Typed Approaches}

  \emph{Autosubst}\cite{DBLP:conf/itp/SchaferTS15}
  is a Coq framework, which derives parallel substitution definitions and
  lemmas for languages from annotated Coq syntax definitions using
  extrinsic typing, extrinsic scoping, and de Bruijn indices.
  The framework is implemented in Coq's tactic language Ltac and comes
  with a decision procedure for all assumption-free, equational
  substitution-lemmas.
  The implementation of Autosubst deals with multiple variable sorts
  by generating multiple substitutions and corresponding interaction lemmas.

  \emph{Autosubst 2}\cite{DBLP:conf/cpp/StarkSK19} is a standalone
  code generator, which translates second-order HOAS specifications into
  mutual inductive term sorts. Compared to Autosubst 1, it features
  mutually recursive object languages, intrinsically scoping, and
  vectorized substitutions.
  Compared to our work, the syntax they generate takes the form of
  what we described as \emph{unsorted syntax} in
  Section~\ref{sec:syntax}, i.e.\ different syntactic categories are
  described by different types with different amount of indices for
  variable counts. To eliminate the need for interaction lemmas, they
  define the notion of \emph{vectorized substitution}, which combines
  the individual substitutions by putting them in a vector.
  We believe their great work of creating a decision procedure for
  vectorized substitutions should also translate to our setting with
  multi-sorted substitutions.

  \emph{Needle and Knot}\cite{DBLP:conf/esop/KeuchelWS16} is a code
  generator for unscoped syntax with de Bruijn indices. They generate
  substitution and interaction lemmas for single-pointed substitution
  for languages with multiple variable sorts and binders that bind
  lists of variables.
  
  All of the above work does not provide machinery to model typing
  and type preservation and does not unify renaming and substitution and
  their compositions.
  Hence, type preservation needs to be modeled manually and
  individually for renamings and substitutions.


  % Abstract binding trees

  \subsection{Intrinsically Typed Approaches}

  Allais et al.\cite{DBLP:conf/cpp/Allais0MM17} propose a powerful
  abstraction for denotational semantics and semantic fusion lemmas.
  In later work\cite{DBLP:journals/pacmpl/AllaisA0MM18}, they use
  generic programming to instantiate this abstraction for a class of
  object languages comparable to ours.
  They demonstrate how both renamings and substitutions can be
  described as semantics, how the four composition lemmas follow from
  their generic fusion lemma, and also provide an abstraction to unify
  renamings and substitutions.
  They show how to use their framework for both intrinsic and
  extrinsic typing, but are missing a story for polymorphism.

  With only a slight modification to their framework, we can instantiate it
  for multi-sorted syntax, enabling the definition of polymorphic languages.
  However, as the intrinsic typing is then
  used to describe syntactic categories, the semantic abstractions talk about untyped
  terms, so typing and type preservation lemmas have to be modeled entirely manually.
  We believe it would be worthwhile to explore how their semantics
  abstractions can be lifted to typing relations similar to how our typing kits lift
  regular kits from terms to typing relations.

  % \subsection{Fibrational}
  % \cite{DBLP:conf/rta/LicataSR17}

  \subsection{Pure Type Systems}
  Pure Type Systems\cite{DBLP:conf/esop/BarendregtH90, berarditowards, terlouw1989een}
  describe a class of typed lambda calculi parameterized over a set of
  sorts, dependencies between sorts, and rules for quantification.
  While pure type systems may seem very similar to multi-sorted
  syntax, they are actually quite different:
  \begin{itemize}
  \item 
    In multi-sorted syntax, sorts describe syntactic categories of terms. Terms
    of different sorts are kept syntactically different, e.g. the set of expressions
    \ACode{S ⊢ 𝕖} and types \ACode{S ⊢ 𝕥} in our System F example.
  \item 
    In pure type systems, sorts are universe types, e.g.\ like
    \ACode{Set} in Agda or \ACode{Prop} in Coq.
    Terms which have different sorts as types, do still belong to the
    same syntactic category.
  \end{itemize}

  We can model pure type systems as a multi-sorted syntax with a single sort,
  where the sorts of the pure type system occur as terms representing universe types.

  % We can use our framework to model pure type systems, but the sorts of pure type systems
  % do not correspond to the sorts of the multi-sorted syntax. The multi-sorted syntax
  % has just a single sort that describes all terms, as it is common for
  % dependently typed languages.

  \section{Conclusion}
  \label{sec:conclusion}
  % We have presented a framework for deriving untyped substitution and its properties, and
  % and abstraction for proving type preservation of substitution with a single lemma.

  % Using extrinsic typing allowed us to unify the renamings and
  % substitutions for variables of arbitrary many syntactic categories.

  % Furthermore, extrinsic typing allowed us treat untyped substitution
  % and its properties separately from typing and type preservation.
  % This has the benefit that the former can be derived automatically for virtually
  % any object language, while the latter is more domain specific and
  % can be handled independently.

  % We believe our framework is a viable alternative to intrinsic
  % typing, as the duplication is automated away.

  % We believe our framework is particularly useful for polymorphic languages,
  % where intrinsic typing requires necessarily to deal with multiple substitutions
  % and their interactions. Furthermore, in more complex scenarios, intrinsic typing
  % can easily lead to subst-hell, which is avoided with extrinsic typing.
  
  % We belive the core limitation of our framework are the typing kits, which
  % require a classical ternary typing relation. However, this problem is hard
  % to avoid as typing relations can become arbitrarily complicated.
  % To adapt the framework to more complicated type systems, only the typing
  % kits and typing traversals need to be extended, which we have successfully
  % done for linear typing ala Wood and Atkey\cite{DBLP:journals/corr/abs-2005-02247} and
  % general substructural typing ala Licata et al\cite{DBLP:conf/rta/LicataSR17}.

  % - Main use case: polymorphism / multiple syntactic categories / dependent types
  % - Limitations and Flexibility with only extending typing kits
  % - Comparison with intrinsic typing
  %   - Deriving untyped substitution is on par with intrinsic
  %   - Subst-Hell / Interaction lemmas unavoidable

  We have presented an Agda framework, which automatically derives definitions and lemmas
  for untyped substitution, and provides an abstraction for proving
  type preservation of renaming and substitution for all syntactic
  categories with a single lemma (\ACode{\AField{\_⊢⋯\_}}).

  Compared to many extrinsically typed approaches, our framework also models
  typing and type preservation. Compared to many intrinsically typed approaches, our
  framework gracefully extends to polymorphic scenarios.

  The main limitation of our framework is the shape of typing relations, similarly
  as it is the case with approaches based on intrinsic typing: we can
  only model classical ternary typing relations.
  To adapt our framework to more complicated typing relations, the
  machinery for untyped substitution can be reused, but the
  abstractions related to typing need to be modified.
  We found that this works surprisingly well in practice,
  where we have already made extended typing abstractions that support
  linear typing ala Wood and Atkey\cite{DBLP:journals/corr/abs-2005-02247} and
  general substructural typing ala Licata et al\cite{DBLP:conf/rta/LicataSR17}.
  In both cases, the typing relation is extended with a fourth
  component that models usage restrictions on the type context.

  While intrinsic typing allows to unify definitions with their type
  preservation proofs, extrinsic typing allows to unify
  substitutions across different syntactic categories, as we have demonstrated.
  We believe this makes our framework particularly suited for polymorphic languages,
  where the downside of extrinsic typing is automated away, and where we have variables
  across multiple syntactic categories, so the benefits of a unified
  substitution bear fruits.
  % Furthermore, extrinsic typing allows us
  % to avoid the ``subst-hell'', which typically appears in formalizations
  % of logical relations for polymorphic languages.
  % We believe this makes extrinsic typing more suitable for polymorphic languages:
  % with extrinsic typing, the definitions and lemmas for untyped
  % substitutions can be automated for virtually any object language,
  % whereas with intrinsic typing, it seems impossible to unify
  % substitutions across syntactic categories, because an intrinsically
  % typed multi-sorted syntax would require to index terms with terms,
  % which is the same problem that occurs with giving intrinsic types to a dependently typed language.




  % In our opinion, our framework makes a case for extrinsic typing for
  % polymorphic, languages as the

  % \bibliographystyle{ACM-Reference-Format}
  \bibliography{paper}

  \clearpage
  % \appendix
  % \onecolumn

  % \section{Omitted Proofs}
  % \label{sec:proofs}

  % \subsection{Proofs for Section~\ref{sec:maps}}
  % \LibCode\KIdLift
  % \LibCode\KIdLiftProof

  % % \AppCode\FTraversalId
  % % \AppCode\FTraversalIdProofInteresting
  % % \LibCode\FTraversalIdProofRest

  % \subsection{Proofs for Section~\ref{sec:composition}}
  % \LibCode\KCKitAp
  % \LibCode\KCKitApProof

  % \LibCode\KDistLiftCompose
  % \LibCode\KDistLiftComposeProof

  % \LibCode\KCommLiftWeaken
  % \LibCode\KCommLiftWeakenProof

  % \LibCode\KCommLiftWeakenTraverse
  % \LibCode\KCommLiftWeakenTraverseProof

  % \LibCode\KWeakenCancelsSingle
  % \LibCode\KWeakenCancelsSingleProof

  % \LibCode\KWeakenCancelsSingleTraverse
  % \LibCode\KWeakenCancelsSingleTraverseProof

  % \LibCode\KDistLiftSingle
  % \LibCode\KDistLiftSingleProof

  % \LibCode\KDistLiftSingleTraverse
  % \LibCode\KDistLiftSingleTraverseProof


  % % \AppCode\FFusion
  % % \AppCode\FFusionProofInteresting
  % % \AppCode\FFusionProofRest


  % \subsection{Proofs for Section~\ref{sec:typing}}
  % \LibCode\KLiftTyping
  % \LibCode\KLiftTypingProof

  % \LibCode\KSingleTyping
  % \LibCode\KSingleTypingProof


  % % \AppCode\FSubjectReduction
  % % \AppCode\FSubjectReductionProofInteresting


  % % \section{Generic Class of Object Languages}
  % % \label{sec:generic-class}


  % % \section{System F with Reflection}
  % % \label{sec:reflection-example}


  % % \section{Map Equality Without Functional Extensionality}
  % % \label{sec:fun-ext}


  % % \section{Features of the Actual Implementation}
  % % \label{sec:features}

\end{document}