% \documentclass[sigplan, screen]{acmart}
% \documentclass[sigplan, screen, anonymous, review, authordraft]{acmart}
% \documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\documentclass[sigplan,10pt]{acmart}

\usepackage{agda-unicode}
\usepackage{agda-generated}
\AgdaNoSpaceAroundCode{}

\bibliographystyle{ACM-Reference-Format}

\title{Abstractions for Multi-Sorted Substitutions}

\author{Hannes Saffrich}
\orcid{0000-0002-1825-0097}                 %% \orcid is optional
\affiliation{
  % \department{Department1}                %% \department is recommended
  \institution{University of Freiburg}      %% \institution is required
  \country{Germany}                         %% \country is recommended
}
\email{saffrich@informatik.uni-freiburg.de} %% \email is recommended

% \author{Peter Thiemann}
% \orcid{0000-0002-9000-1239}                 %% \orcid is optional
% \affiliation{
%   % \department{Department2a}               %% \department is recommended
%   \institution{University of Freiburg}      %% \institution is required
%   \country{Germany}                         %% \country is recommended
% }
% \email{thiemann@informatik.uni-freiburg.de} %% \email is recommended

\usepackage{tcolorbox}

\newenvironment{LibCode*}{%
  \begin{tcolorbox}[%
    colframe=white,%
    boxrule=0.0pt,%
    top=2.5pt,%
    left=2.5pt,%
    bottom=2.5pt,%
    right=2.5pt,%
    boxsep=0pt%
  ]\vspace{-0.2\baselineskip}%
}{%
  \vspace{-1\baselineskip}%
  \end{tcolorbox}%
}

\newenvironment{ExampleCode*}{%
  \begin{tcolorbox}[%
    colframe=white,%
    colback=yellow!5,%
    boxrule=0.0pt,%
    top=2.5pt,%
    left=2.5pt,%
    bottom=2.5pt,%
    right=2.5pt,%
    boxsep=0pt%
  ]\vspace{-0.2\baselineskip}%
}{%
  \vspace{-1\baselineskip}%
  \end{tcolorbox}%
}

\newcommand*\LibCode[1]{\begin{LibCode*}{#1}\end{LibCode*}}
\newcommand*\AppCode[1]{{#1}}
\newcommand*\ExampleCode[1]{\begin{ExampleCode*}{#1}\end{ExampleCode*}}

% \setlength\fboxsep{0pt}
% \usepackage{realboxes}
% \definecolor{mygray}{rgb}{0.95,0.95,0.95}
% \newcommand*\ACode[1]{\Colorbox{mygray}{\AgdaFontStyle{#1}}}

% \newcommand*\ACode[1]{\AgdaFontStyle{#1}}

% \newcommand*\ACode[1]{\texttt{#1}}

\definecolor{mygray}{rgb}{0.4,0.4,0.4}
\newcommand*\ACode[1]{\AgdaFontStyle{\textcolor{mygray}{#1}}}

\newcommand*\AField[1]{\AgdaField{#1}}
\newcommand*\ACon[1]{\AgdaInductiveConstructor{#1}}
\newcommand*\AKw[1]{\AgdaKeyword{#1}}
\newcommand*\ADef[1]{\AgdaFunction{#1}}

\begin{document}
  \begin{abstract}
    Variable binding and substitution are a long-standing nuisance for mechanized
    metatheory of programming languages. A common approach is to represent
    variables as DeBruijn Indices, where substitution is defined in terms of
    variable renaming. If a language has $n$ different kinds of variables, and
    $m$ different kinds of terms, we potentially need to define both
    renaming and substitution for all $m\cdot n$ combinations and prove the
    theory of those operations both in isolation and with respect to each other.

    % McBride introduced kits to define both substitution and renaming by a
    % single term traversal for intrinsically typed terms.\cite{mcbride2005kits}

    We propose a technique to derive the implementation and metatheory of
    renaming and substitution for all $m\cdot n$ combinations of variables and terms
    from a single term traversal and three simple lemmas for extrinsically typed
    but intrinsically scoped terms.
    We demonstrate this technique by formalizing type soundness of System F with
    very parallel substitutions, which replace both type and term variables at
    once, enabling a single substitution-preserves-typing lemma.
    We provide a well-documented implementation of the technique as an Agda
    library.

    As the technique is based on extrinsic typing, the metatheory of renaming
    and substitution is decoupled from type preservation.
    This has the downside, that type preservation of renaming and substitution
    are not for free, but also the upside, that the library can be directly
    instantiated for object languages with non-standard typing relations like
    dependent types, type state, or resource environments.
  \end{abstract}

  \maketitle

  \section{Introduction}
  Formalizing metatheory of programming languages in a proof assistant 
  requires to deal with variables, binders and substitution.

  In most languages those constructs behave uniformly,
  i.e. substitution is only concerned with variables and binders and
  behaves homomorphic on all other syntax constructors.

  Intrinsic typing 


  \begin{enumerate}
  \item DeBruijn
  \item Intrinsic vs Extrinsic
  \item Reduction under binder
  \end{enumerate}

  \subsection{Structure}
  The rest of this paper will introduce our framework using System F
  as a running example for a type soundness proof.

  Code of the framework is displayed in gray boxes.
  Code of examples is written in yellow boxes.
  Code of the System F formalization is written without boxes. This is
  the only code a user of our framework has to write.

  In the paper we state all definitions and lemmas, but omit some proofs
  in the interest of space. However the omitted proofs exclusively
  depend on lemmas and definitions stated in this paper. The full code
  from the paper can be found at TODO.

  In the paper we only show the part of the framework necessary for
  the System F soundness proof. The actual implementation is more
  general and complete and can be found at TODO.

  \subsection{Contributions}
  \begin{enumerate}
  \item
    a multi-sorted approach to extrinsic typing;
  \item
    a multi-sorted extension of McBride's kits to unify renamings and substitutions and their metatheory;
  \item
    an abstraction for composition and it's metatheory, unifying the four combinations of renamings and substitutions;
  \item
    an abstraction for typing relations, unifying type preservation of renaming and substitution into a single lemma;
  \item
    an Agda-implementation featuring derived term-kits, representation
    independence for substitutions and typing contexts, heterogeneous
    equality, independence of functional extensionality, case studies
    on System F, dependent lambda calculus, pattern matching, linear
    types.
  \end{enumerate}

  \newpage

  \section{Syntax}
  \subsection{Single-Sorted Syntax}
  The following shows a typical intrinsically-scoped syntax of System F:
  \ExampleCode\FUnsortedSyntax

  \texttt{Type}s are indexed by the number of free type variables \texttt{n}.
  \texttt{Expr}essions are additionally indexed by the number of free expression variables \texttt{m}.
  Variables \texttt{`\_} are represented as DeBruijn-indices, where \texttt{Fin n} is the type of \texttt{n} elements.

  We identify two drawbacks with this style of syntax:
  \begin{enumerate}
  \item the syntactic categories (\texttt{Kind}, \texttt{Type}, and \texttt{Expr})
    have different types, which makes it difficult to treat them uniformly; and
  \item the different sorts of variables are modeled separately, which requires to define not just
    type-in-type and expression-in-expression substitution, but also type-in-expression substitution.
    Consequently, interaction lemmas between those substitutions are required.
    In general, this leads to a combinatory explosion of
    substitutions, e.g.\ adding kind variables would lead to a total of 6
    different substitutions.
  \end{enumerate}
  To avoid these drawbacks, we instead use a multi-sorted syntax.

  \subsection{Multi-Sorted Syntax}
  A multi-sorted syntax is defined by a single type of sort-indexed terms.

  A sort describes to which syntactic category a term belongs and is
  itself indexed by a sort type, which describes whether the syntax
  permits variables of this sort:
  \LibCode\KSortTy
  \AppCode\FSort
  
  The term type \ACode{S \ACon{‚ä¢} s} is then indexed by its sort
  \ACode{s} and the sorts of its free variables \ACode{S}.
  For example, \ACode{\ACon{[ùï•, ùï•] ‚ä¢ ùïñ}} is the type of expressions
  (\ACode{\ACon{ùïñ}}) with two free type-variables (\ACode{\ACon{ùï•}}).
  \newpage
  \AppCode\FSyntax
  The notation \ACode{\ACon{\_‚ä¢\_}} is often used for terms in
  intrinsically-typed languages. This is no accident: in effect, we
  defined an intrinsically-typed language with the twist that the
  typing relation assures exactly that the syntactic categories are followed.
  Sorts \ACode{s} correspond to types, and lists of sorts \ACode{S}
  correspond to type environments.

  As it is typical in intrinsic typing, variables are represented as
  typed (in our case sorted) DeBruijn indices \ACode{S \ACon{‚àã} s}, i.e.\
  values of the usual proof-relevant list-membership relation:
  \LibCode\KVariables

  Contrary to the usual intrinsic typing, we limit the environment
  \ACode{S} to sorts with index \ACode{\ACon{Var}}.
  This ensures that it is impossible to construct kind variables, as
  it is not possible to extend \ACode{S} with the sort of kinds
  \ACode{\ACon{ùïú}}.

  \subsection{A Structure for Multi-Sorted Syntax}
  The multi-sorted syntax makes it easy to define a structure for
  syntaxes of arbitrary object-languages, i.e.\ syntaxes with
  arbitrary amounts of syntactic categories and variables:
  \LibCode\KSyntax
  The first three fields record the definitions of sorts, terms, and variable introduction.
  The last field records that variable introduction
  \ACode{\AField{`\_}} is injective, which is trivially true for
  constructors. The instantiation for our System F syntax is
  straightforward:
  \AppCode\FSyntaxInst

  \section{Renamings \& Substitutions}
  \subsection{Multi-Sorted Renamings \& Substitutions}
  Working with a sort-indexed syntax allows us to define renamings and substitutions
  that replace all variables of all sorts simultaneously:

  \ExampleCode\FExampleSubRen

  A renaming \ACode{S‚ÇÅ \ADef{‚Üí·µ£} S‚ÇÇ} maps variables from \ACode{S‚ÇÅ} to
  variables from \ACode{S‚ÇÇ}.
  A substitution \ACode{S‚ÇÅ \ADef{‚Üí‚Çõ} S‚ÇÇ} maps variables from \ACode{S‚ÇÅ} to
  terms with free variables from \ACode{S‚ÇÇ}.

  For example, the substitution, which replaces the term variable 0 with the
  identity function and the type variable 1 with the bottom type, is defined
  as followed:
  \ExampleCode\FExampleSub

  This representation has the benefit that there is no combinatory
  explosion of substitutions and renamings, e.g.\ no extra lemmas have to be
  proved between an expression-in-expression and a type-in-expression
  substitution, because both are simply substitutions.

  \subsection{The Need for Renamings}
  A problem with mechanizing languages with DeBruijn-indices is that
  the operation of applying a substitution \ACode{œÉ} to a term
  \ACode{t} cannot be defined directly by structural recursion on
  \ACode{t}.
  If \ACode{t} is a term like \ACode{\ACon{Œªx} e},
  where the subterm \ACode{e} is under a binder, then the variables
  in \ACode{e} are shifted, i.e.\ the variable \ACode{\ACon{zero}} refers
  to the variable from the binder, whereas a variable \ACode{\ACon{suc} x}
  refers to the variable \ACode{x} from outside of the binder.
  As the terms contained in \ACode{œÉ} may themselves contain free variables,
  they need to be shifted, too, before they can be substituted
  for variables in \ACode{e}. 
  Shifting the variables in a term is itself a substitution, which maps
  each variable \ACode{x} to the term \ACode{\ACon{`} (\ACon{suc} x)}.
  However, applying this shifting substitution to the terms in
  \ACode{œÉ} is not structurally recursive, as the terms in \ACode{œÉ}
  are not subterms of \ACode{\ACon{Œªx} e}.

  The usual workaround is to first define renamings,
  i.e.\ substitutions that replace variables with variables.
  In contrast to general substitutions, renamings can be easily
  shifted: they only contain variables \ACode{x}, which can be
  shifted by simply taking their successor \ACode{\ACon{suc} x}.
  As the shifting substitution is a renaming, we can then define substitution,
  where we apply the shifting \emph{renaming} to the terms in \ACode{œÉ} when
  the substitution needs to go under a binder.

  % The usual workaround is to define renamings first and use them
  % to weaken the terms in substitutions when going under binders.
  While this keeps lemmas simple (requiring only structural induction),
  it duplicates the amount of work as all operations and lemmas have
  to be defined and proved for both renamings and substitutions.

  \subsection{Unifying Renamings \& Substitutions}
  To avoid the duplication between renamings and substitutions,
  McBride\cite{DBLP:journals/jar/BentonHKM12, unpublished:mcbride2005kits}
  introduced an abstraction called \emph{kits}.\footnote{
    While kits were originally formulated for intrinsically-typed languages,
    they nicely extend to our extrinsically-typed multi-sorted syntax, whose
    sort-indexing is a form of intrinsic typing.
  }

  % A \ACode{Kit} is a structure that captures the commonalities
  % between variables and terms:
  A \ACode{Kit} is a structure that allows to abstract over whether
  something is a term or a variable. The intention is to instanciate
  this structure exactly twice (once for variables and once for terms),
  and then write definitions, which are parameterized over a kit and
  consequently can be used for both variables and terms.
  \LibCode\KKit

  As we intend to have exactly two kit instances, we choose names of
  the form \ACode{x/y}, where \ACode{x} is the name we choose for the
  variable instance, and \ACode{y} is the name we choose for the term
  instance.
  For example the parameter type \ACode{\_‚àã/‚ä¢\_} will be instanciated
  to \ACode{\ACon{\_‚àã\_}} for the variable kit, and to \ACode{\AField{\_‚ä¢\_}} for the
  term kit.

  A kit provides the following operations:
  \begin{itemize}
  \item 
    \ACode{\AField{id/`}} converts a variable \ACode{S \ACon{‚àã} s} into a
    \ACode{S \AField{‚àã/‚ä¢} s}. For the variable kit, \ACode{S ‚àã/‚ä¢ s} is instanciated to \ACode{S \ACon{‚àã} s}, so this
    operation is the identity. For the term kit, \ACode{S ‚àã/‚ä¢ s} is
    instanciated to \ACode{S \AField{‚ä¢} s}, so this operation is the
    variable constructor \ACode{\AField{`\_}}.
  \item 
    \ACode{\AField{`/id}} converts a \ACode{S ‚àã/‚ä¢ s} into a term \ACode{S \AField{‚ä¢} s}
    and is dual to the \ACode{\AField{id/`}} operation.
  \item 
    \ACode{\AField{wk}} shifts the DeBruin-Indices in a \ACode{S ‚àã/‚ä¢ s}.
    The new, unused variable \ACode{\ACon{zero}} can assume any sort \ACode{s'}.
    For variables, \ACode{\AField{wk}} is the successor \ACode{\ACon{suc}}.
    For terms, \ACode{\AField{wk}} means applying a shifting renaming to the term.
  \end{itemize}

  The operations need to satisfy the following properties:
  \begin{itemize}
  \item \ACode{\AField{`/`-is-`}} states that converting a variable first to a ``variable-or-term'' and
    then further to a term is the same as converting it directly to a
    term using the variable constructor \ACode{\AField{`\_}}.
  \item \ACode{\AField{`/id-injective}} and \ACode{\AField{id/`-injective}} state that
    \ACode{\AField{`/id}} and \ACode{\AField{id/`}} are injective. This property
    follows easily, as both the identity function and the variable
    constructor are injective.
  \item \ACode{\AField{wk-id/`}} characterizes the behaviour of the \ACode{\AField{wk}} function.
    Injecting a variable and then shifting it, is the same as injecting a shifted variable.
  \end{itemize}

  Building on the operations and axioms, we derive further operations:\footnote{
    The definitions are included directly in the record module of the
    Kit, so they are implicitly parameterized over a kit.
  }
  \begin{itemize}
  \item 
    We unify the definition of renamings \ACode{S‚ÇÅ \ADef{‚Üí·µ£} S‚ÇÇ} and
    substitutions \ACode{S‚ÇÅ \ADef{‚Üí‚Çõ} S‚ÇÇ}, which differ only in whether they
    return variables or terms:
    \LibCode\KMap
    We call a value of type \ACode{S‚ÇÅ \ADef{‚Üí‚Çñ} S‚ÇÇ} a \emph{map} and
    use the meta-variable \ACode{œï} for it.
  \item 
    A map can be applied to a variable:
    \LibCode\KAp
  \item 
    A map can be extended by a new variable or term:
    \LibCode\KExt
  \item 
    A map can be shifted, as the Kit provides the necessary \ACode{\AField{wk}} operation:
    \LibCode\KWkm
  \item 
    A map can be lifted, which is the operation necessary to
    move a map under a binder of sort \ACode{s}:
    \LibCode\KLift
  \item 
    There is an identity map:
    \LibCode\KId
  \item 
    There is a singleton map, which replaces \ACode{\ACon{zero}} and decreases
    all other variables by one:
    \LibCode\KSingle
  \item 
    There is a map which is equivalent to \ACode{\AField{wk}} on terms:
    \LibCode\KWeaken
  \item
    Maps have an extensional equality:
    \LibCode\KEq
  \item
    For simplicity we postulate functional extensionality:\footnote{
      The actual implementation does \emph{not} use any postulates.
      Appendix TODO explains the workaround.
    }
    \LibCode\KFunExt
  \item
    Lifting the identity map is a (larger) identity map:
    \LibCode\KIdLift
    % \LibCode\KIdLiftProof
  \end{itemize}

  We also specify notation, which makes it less cumbersome
  to explicitly pass a particular Kit to those definitions:
  \begin{itemize}
  \item \ACode{S \ADef{‚àã/‚ä¢[} K \ADef{]} s} is \ACode{S ‚àã/‚ä¢ s} for some \ACode{\ACon{Kit}} \ACode{K}; and
  \item \ACode{S \ADef{‚Äì[} K \ADef{]‚Üí} s} is \ACode{S \ADef{‚Üí‚Çñ} s} for some \ACode{\ACon{Kit}} \ACode{K}.
  \end{itemize}

  The operation of applying a map to a term depends on the concrete
  structure of a term, so we define a structure for it:
  \LibCode\KTraversal
  The fields of this structure are:
  \begin{itemize}
  \item
    \ACode{t \AField{‚ãØ} œï} applies the map \ACode{œï} (a renaming or
    substitution) to the term \ACode{t}.
  \item
    \ACode{\AField{‚ãØ-var}} states that applying a map \ACode{œï} to a variable
    term \ACode{\AField{`} x}, is the same as applying \ACode{œï} to
    the variable \ACode{x}, and then converting the result from \ACode{S‚ÇÇ ‚àã/‚ä¢ S}
    to \ACode{S‚ÇÇ ‚ä¢ S} via \ACode{\AField{id/`}}.
  \item
    \ACode{\AField{‚ãØ-id}} states that applying the identity map
    \ACode{id} to a term does not change the term.
  \end{itemize}

  Finally, we define the actual kit instances.
  The variable kit definition is straightforward:
  \LibCode\KKitVar

  The term kit requires both the variable kit and the
  \ACode{\ACon{Traversal}} to be defined, because shifting a term \ACode{t} with \ACode{\AField{wk}}
  means applying the shifting renaming to the term.
  Hence, we define the term kit in the record module of \ACode{\ACon{Traversal}}:
  \LibCode\KKitTerm

  % The only task left now is to create the two instances for the kits
  % and define how a map can be applied to a term.
  % While the variable kit can be defined as expected, the term kit
  % raises a dependency problem: The \ACode{\AField{wk}} operation for terms requires us
  % to already know how to apply a renaming to term.
  % To solve this problem, McBride came up with a clever solution:
  % Applying a map to a term, can be defined without even having any Kit-instances yet.
  % Afterwards we can first define the variable kit, and in the
  % definition of the term kit, we are then already allowed to apply renamings.
  % After the definition of the term-kit we are then allowed to apply
  % both renamings and substitutions as both kits defined.

  Note that all definitions so far are library code. To make them
  available for our System F example, all we need to do is
  to create an instance of \ACode{\ACon{Traversal}}.

  We start with the operation of applying a map to a term:
  \AppCode\FTraversalOp
  The interesting cases are those with variables and binders:
  \begin{itemize}
  \item 
    In the variable case \ACode{(\ACon{`} x) \ADef{‚ãØ} œï}, we first apply the map
    \ACode{œï} to the variable \ACode{x}. If \ACode{œï} is a renaming,
    we get back a variable and need to apply the variable constructor
    \ACode{\ACon{`\_}} to it. If \ACode{œï} is a substitution,
    we get back a term that we can use directly.
    Hence, the use of \ACode{`/id}.
  \item 
    In cases where the operation needs to go under a binder, like
    \ACode{(\ACon{Œªx} e) \ADef{‚ãØ} œï}, we lift the map using \AField{\_‚Üë\_} before
    we apply it to the subterm, to account for the bound variable.
  \end{itemize}


  \AppCode\FTraversalId
  \AppCode\FTraversalIdProofInteresting
  % \LibCode\FTraversalIdProofRest
  \AppCode\FTraversal
  
  \ExampleCode\FExampleTrav



  % \subsection{Unused}
  % \LibCode\KKitOpenInst
  % \LibCode\KKitOpen

  \section{Map Composition}
  In this section we extend our framework with the composition of
  arbitrary maps.

  Composition of substitutions is important for most language
  formalizations, as it allows to reason about the meaning of applying
  multiple substitutions to a term. This appears for example in the proof of
  substitution-preserves-typing for System F, where in the
  case of type-application \ACode{(e \ACon{‚àô} t) \ADef{‚ãØ} œÉ} we need to reason about
  \ACode{(e \ADef{‚ãØ} \ADef{‚¶Ö} t \ADef{‚¶Ü}) \ADef{‚ãØ} œÉ}, which is equivalent to
  \ACode{e \ADef{‚ãØ} (\ADef{‚¶Ö} t \ADef{‚¶Ü} \ADef{¬∑‚Çñ} œÉ)},
  where \ACode{\_\ADef{¬∑‚Çñ}\_} is backward composition.

  As we defined substitution in terms of renamings, we need to
  consider all four compositions between renamings and substitutions.
  While the composition operations are defined independently of each other,
  the \ACode{\AField{‚ãØ-assoc}} lemma for two substitutions, depends on the
  \ACode{\AField{‚ãØ-assoc}} lemmas between a renaming and a substitution, which in
  turn depend on the \ACode{\AField{‚ãØ-assoc}} lemma between two renamings.

  McBride et al.\cite{DBLP:journals/jar/BentonHKM12} addressed this
  issue by duplicating the definitions and using tactics to reduce
  boilerplate in proofs.

  In contrast we define structures similar to \ACode{\ACon{Kit}} and
  \ACode{\ACon{Traversal}}, which allows us to abstract over all four
  compositions and use the same trick as before to eliminate the
  dependencies.
  This has the benefit that a user of our library has to write less
  boilerplate, but more importantly it allows to prove lemmas about the
  composition of arbitrary maps, which enable us later to unify type
  preservation of all substitution and renaming operations into a single
  lemma.

  \subsection{An Examination of Composition}
  With the infrastructure we build in the previous sections, we can
  define the four compositions as followed:
  \ExampleCode\KExFourComps
  The definitions reveal an interesting asymetry, in the sense that
  the first argument of composition guides the implementation: if we
  compose a renaming with any map, then we first apply renaming to the
  the variable, which yields another variable, so we apply the second
  map to that \emph{variable}.
  However, if we compose a substitution with any map, then we first
  apply the substitution to that variable, which yields a term, so we
  need to apply the second map to that \emph{term}.

  With the machinery, we built so far, we can unify the first two and
  last two compositions as followed:
  \ExampleCode\KExTwoComps

  But to unify those two compositions, we need a new abstraction.

  \ExampleCode\KComposition
  
  \subsection{WkKits}

  In the definition of \ACode{\ACon{Kit}} we required the axiom
  \ACode{\AField{wk-id/`}}, which captured the interaction between
  \ACode{\AField{wk}} and \ACode{\AField{id/`}}:
  \ExampleCode{\KWkId}
  Injecting a variable with \ACode{\AField{id/`}} and then shifting it,
  is the same as injecting a shifted variable.

  Now that we have defined the \ACode{\ACon{Traversal}} structure, we
  can formulate a similar interaction between
  \ACode{\AField{wk}} and \ACode{\AField{`/id}}:
  \ExampleCode{\KIdWk}
  Shifting a variable/term \ACode{x/t} with \ACode{\AField{wk}} and then injecting
  it to a term, is the same as injecting \ACode{x/t} to a term and then applying
  a shifting renaming.
  

  As this lemma depends on map application \ACode{\ADef{\_‚ãØ\_}} being
  already defined, we cannot add it to the original \ACode{\ACon{Kit}}
  structure, but need to define a new structure for it, which we call
  a \ACode{\ACon{WkKit}}:
  \LibCode\KWkKit

  We then create exactly two instances of the \ACode{\ACon{WkKit}} for
  the variable and term kit, respectively. 
  \LibCode\KWkKitInstances

  Both the structure and the instances are part of the library and do
  not require application code.

  \subsection{Composition}

  Using the \ACode{\ACon{WkKit}}, we then define
  the \ACode{\ACon{ComposeKit}} and \ACode{\ACon{ComposeTraversal}}
  structures, which serve analogous purposes to \ACode{\ACon{Kit}}
  and \ACode{\ACon{Traversal}} from before:
  the library provides a \ACode{\ACon{ComposeKit}} for each of the
  four compositions, whereas the \ACode{\ACon{ComposeTraversal}}
  structure needs to be instanciated by the application with
  lemmas parameterized over arbitrary \ACode{\ACon{ComposeKit}}s.
  This gives the user a composition operation
  \ACode{\AField{\_¬∑‚Çñ\_}} between arbitrary maps and corresponding
  lemmas, instead of multiple definitions and lemmas about concrete
  maps, enabling us to reason on a more abstract level and to avoid
  further boilerplate.



  \LibCode\KComposeKit
  \LibCode\KComposition
  \LibCode\KComposeKitAp
  % \LibCode\KComposeKitApProof
  \LibCode\KDistLiftCompose
  % \LibCode\KDistLiftComposeProof
  \LibCode\KComposeKitNotation
  \LibCode\KComposeTraversal
  \LibCode\KCommLiftWeaken
  % \LibCode\KCommLiftWeakenProof
  \LibCode\KCommLiftWeakenTraverse
  % \LibCode\KCommLiftWeakenTraverseProof
  \LibCode\KComposeKitInstances
  \LibCode\KComposeKitInstancesConcrete
  \LibCode\KWeakenCancelsSingle
  % \LibCode\KWeakenCancelsSingleProof
  \LibCode\KWeakenCancelsSingleTraverse
  % \LibCode\KWeakenCancelsSingleTraverseProof
  \LibCode\KDistLiftSingle
  % \LibCode\KDistLiftSingleProof
  \LibCode\KDistLiftSingleTraverse
  % \LibCode\KDistLiftSingleTraverseProof

  \subsection{System F}
  \AppCode\FAssoc
  \AppCode\FAssocProofInteresting
  % \AppCode\FAssocProofRest
  \AppCode\FComposeTraversal

  \section{Types \& Contexts}
  \subsection{Library}
  \LibCode\KTypeSorts
  \LibCode\KTypes
  \LibCode\KContextHelper
  \LibCode\KContexts
  \LibCode\KContextLookup
  \subsection{System F}
  \AppCode\FTypes

  \section{Typing}
  % TODO move to typing section
  The only drawback we found, is that types can now also be indexed
  with free expression variables, even though types can never contain
  free variables as assured by the variable constructor. However, this
  only causes minor issues.

  \subsection{Library}
  \LibCode\KVariableTyping
  \LibCode\KTyping
  \LibCode\KTypingKit
  \LibCode\KMapTyping
  \LibCode\KLiftTyping
  % \LibCode\KLiftTypingProof
  \LibCode\KSingleTyping
  % \LibCode\KSingleTypingProof
  \LibCode\KTypingNotation
  \LibCode\KTypingTraversal
  \LibCode\KTypingInstances
  % \LibCode\KTypingTraversalNotation
  \subsection{System F}
  \AppCode\FTyping
  \AppCode\FTypingInst
  \AppCode\FPreserve
  \AppCode\FTypingTraversal

  \section{Semantics}
  % \AppCode\FValues
  \AppCode\FReduction

  \section{Subject Reduction}
  \AppCode\FSubjectReduction
  \AppCode\FSubjectReductionProofInteresting
  % \FSubjectReductionProofRest

  \section{Reflection \& Generics}

  \section{Beyond System F}
  \begin{itemize}
  \item
    Binders with multiple variables are supported and even pattern
    matching can be encoded.
  \item
    Heterogenous equality
  \end{itemize}

  \section{Future Work}
  \begin{itemize}
  \item
    Enabling more object languages by allowing subterms with less
    restrictions on the form of \ACode{S}.
  \end{itemize}

  \section{Related Work}
  Autosubst \cite{DBLP:conf/cpp/StarkSK19, DBLP:conf/itp/SchaferTS15}.
  Kits \cite{DBLP:journals/jar/BentonHKM12, unpublished:mcbride2005kits}.
  Kits linear \cite{DBLP:journals/corr/abs-2005-02247}.
  Universe \cite{DBLP:journals/pacmpl/AllaisA0MM18}.

  \section{Conclusion}

  % \bibliographystyle{ACM-Reference-Format}
  \bibliography{paper}

  \clearpage
  \appendix
\end{document}